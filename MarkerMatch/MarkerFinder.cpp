#include "MarkerFinder.h"
#include <fstream>
#include <opencv2/imgproc/types_c.h>

#define  SAVE_FINAL_BINARYIMG_LOCPATTERN 0   //保存在模板匹配函数中的最终二值化图,用于测试匹配函数;
#define  ENABLE_TEST  0

#define n48Size 901
//空心十字检测参数;
const double g_hcCoeff_48[n48Size] = {-0.043842,-0.018538,0.019566,0.021250,-0.046848,-0.020150,-0.017663,-0.035310,-0.025036,-0.007348,0.039808,0.130040,0.115198,0.007680,-0.037860,-0.033126,-0.048497,-0.045227,0.058688,0.086421,0.010981,0.034998,-0.019146,-0.034862,-0.031918,-0.048147,-0.028605,0.044151,0.068273,0.056848,0.094357,0.015445,-0.059533,-0.042164,-0.051508,-0.012849,0.021689,0.071478,0.083281,0.119746,-0.007059,-0.017744,-0.022719,-0.042239,0.001823,0.112803,0.111555,0.065052,0.031366,-0.036489,-0.012984,-0.032553,-0.030421,0.121696,-0.042131,-0.041505,-0.009199,0.098178,0.037784,0.001513,-0.026131,-0.030734,0.002789,0.051980,-0.011735,0.030995,0.049667,0.034641,0.009271,-0.032863,-0.038064,0.041086,0.124866,0.005947,-0.029734,-0.043204,-0.097938,-0.019030,-0.026110,0.023010,0.137147,0.060078,-0.015768,-0.032449,-0.031351,-0.057998,0.005901,0.020646,0.102090,0.113770,0.084541,0.004282,-0.012807,-0.011746,-0.064076,-0.015843,-0.041740,-0.027768,0.081651,0.001625,0.002606,-0.014690,0.001398,0.015733,0.039738,-0.006166,0.000810,0.043983,-0.002593,0.021350,0.023979,-0.002957,-0.029585,0.061322,0.054959,0.115056,0.068143,-0.041999,0.038760,0.029458,-0.013079,-0.022864,0.041129,0.037464,0.045444,0.019290,-0.030611,0.038478,0.040802,0.052401,0.021018,0.070056,0.027460,0.011947,-0.022734,-0.076350,0.032052,0.018551,0.010097,0.017697,0.050862,0.039575,0.022697,-0.015383,0.003285,0.020523,0.011998,-0.024474,-0.042355,-0.003212,0.022001,0.064176,0.060937,0.016687,-0.021826,-0.010303,0.012464,-0.002902,-0.044260,-0.068300,-0.026732,0.025837,-0.062722,0.009680,-0.012535,-0.045230,-0.021117,0.019770,0.021711,0.099370,0.081255,-0.056787,-0.032693,-0.041880,-0.021792,-0.001365,-0.035160,-0.018370,0.100650,0.018074,0.086322,0.104695,-0.003757,0.011052,0.016620,-0.003713,-0.013655,-0.040077,-0.056744,0.052169,0.030207,-0.061583,-0.016839,-0.018430,-0.010782,-0.023468,-0.025206,0.011644,0.033662,0.094273,-0.023115,0.017952,0.103527,0.039000,0.014708,0.018204,0.050482,0.042519,0.071705,-0.034802,-0.031287,-0.000003,0.008500,-0.024598,-0.015198,0.053198,0.043845,-0.015574,-0.009338,0.040524,0.020480,0.020079,0.011454,0.031229,0.009198,-0.051452,-0.033860,0.058399,0.092719,0.094774,0.022207,-0.017889,0.005796,-0.032316,0.086217,0.063334,0.041187,0.028668,-0.014801,-0.008583,-0.004530,-0.000288,-0.001985,0.055167,0.064684,0.046646,0.060241,0.026646,-0.002416,-0.013803,0.003563,-0.035582,-0.027829,0.006209,0.023397,0.070022,0.035111,0.021909,-0.018298,-0.007279,-0.049839,-0.011248,0.027976,0.005134,0.026726,0.079319,0.086172,0.038501,0.010101,-0.032299,-0.045740,-0.024850,-0.023775,0.037581,0.020891,0.020905,-0.009568,0.011771,-0.047736,-0.037127,-0.045791,-0.065831,-0.040511,0.002120,0.115853,0.046536,0.079579,-0.028229,-0.026926,0.006059,0.004670,0.038509,0.023711,0.030295,-0.015519,-0.006148,-0.006581,0.024658,-0.012795,-0.028721,0.002939,0.017948,0.006898,-0.026980,0.056141,0.083730,-0.009059,-0.030249,-0.046577,-0.026966,-0.020378,0.051946,-0.019745,0.097449,0.077544,0.134511,-0.016152,-0.051956,-0.034393,-0.059257,-0.043375,-0.050198,0.062731,0.096666,-0.031813,-0.024700,-0.040230,-0.034087,-0.017242,0.011642,0.009028,0.119392,0.086535,-0.090957,-0.029479,-0.060531,-0.039150,-0.045478,-0.018439,0.011500,0.171119,0.021586,0.086079,0.012931,0.015937,0.054975,0.028080,0.000075,-0.034782,0.062463,0.034283,-0.047910,0.021562,0.049323,0.062149,0.037860,0.042026,0.005979,0.118843,-0.033777,0.067053,0.051207,-0.044406,-0.010279,0.041452,0.050028,0.009748,0.017905,0.048863,0.068304,0.094987,0.006382,-0.015678,-0.025809,-0.009279,-0.039939,-0.035848,0.020824,-0.028719,-0.016313,-0.028404,0.014571,0.046274,0.053934,-0.040993,-0.034953,-0.025462,0.014464,-0.022379,-0.036587,-0.017927,-0.012930,-0.004143,-0.020127,0.068249,0.016381,0.100337,0.117605,0.038978,-0.004281,-0.062357,-0.021448,-0.025481,-0.048714,-0.021256,0.086870,0.107406,0.022582,0.004878,-0.044566,-0.018416,-0.029648,-0.050245,-0.069071,-0.013306,-0.047995,-0.055411,-0.039472,-0.045417,0.010357,0.050101,0.142433,0.082477,-0.095201,-0.044989,-0.046672,-0.060400,-0.047452,0.019385,0.034189,0.113291,0.005206,-0.026617,-0.009722,0.004908,0.026663,0.023392,0.019462,-0.004087,0.009849,-0.016423,-0.038073,-0.046513,-0.065310,-0.041206,0.012128,0.055227,0.036892,0.119959,0.068982,-0.076809,-0.011726,0.043803,-0.024712,0.014704,0.013814,0.009455,-0.014424,-0.038891,0.027134,0.132783,0.146731,0.118342,0.001162,-0.075439,-0.072050,-0.069492,-0.050220,-0.039048,-0.028407,-0.046383,-0.034334,-0.039273,-0.013473,-0.021812,0.112663,0.109880,0.087942,-0.002750,-0.018308,-0.014574,-0.024094,-0.026518,-0.040123,0.069207,0.117815,0.118216,0.159941,0.072821,0.023879,-0.055030,-0.104745,-0.087934,-0.070496,-0.086716,0.089910,0.121085,-0.025931,-0.049230,-0.063882,-0.043429,-0.058023,-0.074122,-0.016494,0.063172,0.010518,0.034104,0.073206,0.082794,-0.001567,-0.063910,-0.020126,0.010283,-0.042836,0.005773,0.057686,0.126474,0.150666,0.109375,-0.024737,-0.039114,-0.073005,0.053589,0.020915,-0.030432,0.000315,0.046966,-0.007193,-0.021898,-0.060522,-0.023560,-0.090036,-0.056491,-0.036741,0.052181,0.095849,0.098831,0.037156,0.005897,-0.086875,-0.002940,0.021983,0.005843,-0.014900,0.026277,0.040477,0.009731,0.016001,0.013886,0.068620,-0.010044,-0.038798,-0.042220,-0.048084,-0.031514,-0.002253,0.045470,0.117505,-0.044700,0.014653,0.007336,-0.046326,-0.081481,0.010188,0.097641,0.097677,0.072099,0.067788,0.014446,-0.021963,-0.042658,-0.082789,-0.028612,-0.006230,0.080525,0.070702,0.006735,-0.064189,-0.059690,-0.038316,-0.029098,0.005804,0.047824,0.141659,0.107765,-0.105363,-0.061596,-0.044462,-0.023803,-0.022158,0.058914,0.048164,0.136639,0.072431,0.042409,-0.027450,-0.023674,0.007874,0.029490,0.044869,-0.008834,0.070528,0.021581,-0.030815,-0.042772,-0.010588,0.057367,0.079166,0.068009,0.011377,0.014823,-0.006467,-0.043988,-0.011645,0.011453,-0.012799,-0.039188,0.034217,0.008904,0.009855,0.016956,0.040571,0.096905,0.170076,0.133805,0.003728,-0.084930,-0.095614,-0.081650,-0.026576,-0.040466,-0.066211,-0.013983,-0.002096,0.051988,0.089302,0.031557,0.028021,0.033241,-0.012618,0.017790,0.099230,0.113894,0.067982,-0.025641,-0.065703,-0.057365,-0.019386,0.086921,0.127313,0.062638,0.061196,-0.007637,-0.049227,-0.051676,-0.047424,-0.055061,0.111634,0.113256,-0.056190,-0.046380,-0.057483,-0.021592,-0.027235,-0.032898,0.012481,-0.010427,0.001049,0.055917,0.098606,0.073514,0.011742,-0.022559,-0.042530,-0.049914,0.046993,0.020461,-0.016127,0.037077,-0.002739,0.006141,-0.020042,-0.010962,0.057856,0.092395,0.077700,-0.043879,-0.030163,-0.022506,0.030239,0.010599,-0.014853,0.040516,-0.021870,0.052790,0.037111,0.048421,0.058897,0.046258,0.063884,0.045008,-0.060621,0.076998,0.087227,-0.038507,-0.033246,-0.068561,-0.022222,-0.011315,-0.006852,0.024598,0.058615,0.138051,0.009106,-0.027894,-0.060165,-0.028330,0.019854,0.016227,-0.117815,-0.016817,-0.004294,-0.009023,-0.024639,-0.063883,0.020946,0.068146,0.084480,0.085121,0.005513,-0.002405,-0.023672,-0.019733,0.001784,0.129225,-0.003639,0.059509,0.055065,-0.033392,-0.045819,-0.048622,-0.034910,-0.009696,0.043203,0.017669,-0.062805,-0.049264,-0.074319,-0.056552,-0.047829,-0.038692,0.038303,0.171467,0.085771,-0.031456,-0.060410,-0.000783,-0.012283,0.011758,0.025011,0.058897,0.080165,-0.037726,-0.034627,-0.034442,0.021304,0.002747,0.041761,0.028987,0.074133,0.071191,-0.021742,-0.032342,-0.043346,-0.048451,-0.005068,0.014284,0.004597,0.055750,0.137216,0.084892,0.032948,-0.013574,0.033772,0.041562,0.044712,0.025847,-0.001896,0.079965,0.028515,0.096964,0.078215,0.029478,0.001749,0.018224,-0.010492,-0.011208,0.027518,-0.018441,-0.022817,-0.000843,0.030076,-0.014485,-0.023901,0.019448,0.041143,0.021298,-0.040936,-0.076616,-0.020912,0.137317,0.043622,0.028716,-0.024802,-0.060005,-0.018003,-0.049672,-0.010972,0.095253,0.117705,0.103501,0.024450,-0.015079,-0.051849,0.014498,-0.023726,-0.039048,0.088019,-0.003957,-0.040546,0.031971,0.101099,0.061567,0.043617,0.016125,-0.043201,-0.050875,-0.013791,-0.026831,-0.002514,0.061996,0.010620,0.024200,0.031026,-0.020796,-0.000401,0.113769,0.069622,0.071226,0.083372,-0.021685,0.048853,0.061301,0.003134,0.017922,-0.005091,-0.016926,0.024167,0.062701,-0.058316,0.026423,0.077406,0.005922,-0.075787,0.086122,0.085913,0.026105,0.030218,-0.035276,-0.019836,0.002826,-0.016927,-0.008514,0.037121,0.158195,0.022785,-0.021129,-0.040803,-0.034517,-0.008816,-0.008658,-0.104444,0.018121,-0.006512,0.041848,0.065347,-0.042867,-0.020404,0.024170,-0.022423,-0.043444,-0.014970,-0.026824,-0.034510,-0.029537,-0.038353,-0.027590,-0.008349,0.021948,-0.009079,-2.746998};
//实心十字检测参数;
const double g_scCoeff_48[n48Size] = {0.011314,0.041145,0.057675,0.130656,0.088781,-0.079858,-0.072506,-0.041080,-0.046738,0.025202,0.000149,-0.025301,-0.019453,-0.085137,-0.106970,-0.057582,-0.030235,0.007541,0.007103,0.011266,0.006384,0.098947,0.082444,-0.058195,-0.059087,-0.019316,0.018208,0.082575,0.011456,-0.011543,0.038405,-0.085470,-0.085269,-0.050091,-0.030271,0.078290,-0.042340,-0.035960,0.017432,0.079057,-0.046214,-0.028014,-0.030239,-0.016573,-0.017372,-0.012556,0.054907,0.102632,0.188807,0.031923,-0.040985,-0.048416,-0.030870,-0.049767,0.019905,0.017895,0.002217,0.082681,-0.012965,-0.022146,-0.039347,-0.019410,0.008513,-0.031284,0.007253,0.035504,0.196752,0.095542,-0.057630,-0.017343,-0.032251,-0.070552,0.105658,0.098690,0.067543,0.109918,-0.098040,-0.048853,-0.021105,0.011177,0.043139,0.051382,0.060616,0.008331,-0.023571,-0.061553,0.164108,0.056854,0.044951,0.093435,-0.055186,0.015133,0.000760,0.147447,0.088393,-0.053860,-0.023555,-0.039840,-0.062287,-0.052095,0.003094,-0.023593,0.063499,0.041933,0.099484,-0.002882,-0.020020,-0.036303,-0.051628,-0.031506,-0.067733,-0.052857,0.062812,0.235697,0.078595,0.014363,-0.007800,-0.049636,-0.035965,-0.024505,0.018484,0.008096,0.106110,0.000176,0.007806,-0.029437,-0.117702,-0.060465,-0.110068,-0.030547,0.053531,0.173072,-0.011683,-0.011793,-0.022245,-0.013313,-0.038171,-0.063675,0.016391,-0.009211,0.055344,-0.038688,0.009852,0.012664,0.052642,-0.019582,-0.030243,-0.026103,-0.108094,-0.018586,-0.045125,0.008997,0.042899,-0.055782,-0.081878,-0.113922,0.017204,-0.025420,0.015135,-0.041481,0.019088,-0.047218,0.043802,0.012356,-0.056025,-0.028689,-0.096228,-0.030209,-0.057538,0.039653,0.087856,-0.061706,-0.030133,-0.068654,0.013588,-0.046902,0.071533,0.018619,0.096368,0.009966,0.044450,0.017646,0.012070,0.030004,0.026043,-0.055250,-0.050131,0.002908,0.034617,0.084468,-0.048613,0.015509,0.046547,-0.049915,-0.035531,-0.050400,-0.008366,0.077339,0.031029,0.046490,0.022449,0.101890,0.111128,-0.007779,-0.030595,-0.004941,-0.052328,0.055245,0.041432,0.046178,0.017803,-0.057158,-0.025395,-0.039695,0.001057,0.002620,0.103242,0.048883,0.016505,0.059221,-0.015432,-0.040746,-0.028975,0.000840,0.025973,0.031434,0.062761,0.015670,0.101946,0.054283,-0.053605,0.003101,-0.017391,-0.054647,0.072458,0.069463,0.019503,0.022086,-0.099341,-0.040739,-0.017738,0.022894,0.054627,0.038055,0.082265,0.032017,0.056166,-0.064366,-0.102193,-0.042648,-0.031961,0.008659,-0.070274,-0.001644,0.016088,0.135588,0.138237,0.040028,0.029980,-0.026429,-0.079364,-0.083545,-0.052794,-0.059138,0.078047,0.119422,0.134011,0.065743,0.009513,-0.017852,-0.033840,0.056532,0.049387,0.095374,0.022352,-0.025772,-0.019773,-0.041537,-0.100915,-0.181572,-0.103535,-0.099788,-0.039331,-0.051711,0.098598,0.077382,0.034799,-0.091145,-0.055693,-0.078202,-0.101765,-0.018436,0.082163,0.119329,0.004338,-0.010219,0.003332,0.054555,-0.022774,-0.060412,-0.006000,0.050059,0.063075,-0.006442,0.049230,0.105385,-0.060479,-0.101123,-0.136691,-0.086414,-0.055443,0.090796,0.028453,0.008728,-0.009052,0.088880,-0.014997,-0.060634,-0.043003,-0.035063,0.019302,-0.017688,0.028859,0.068801,0.052413,-0.013479,-0.055289,-0.041865,-0.058720,0.039663,-0.004015,0.073729,0.130994,-0.044835,-0.049972,-0.072006,-0.027274,-0.029464,0.108335,0.060991,0.073323,0.033894,0.061464,-0.007567,0.003518,-0.005582,-0.011904,0.040435,-0.059787,0.009203,0.055247,-0.023756,-0.059027,-0.011778,-0.027926,0.010287,0.102731,0.006140,0.048762,-0.016555,-0.050610,-0.037161,-0.032174,0.059666,0.159024,0.065864,0.034964,0.015314,-0.063173,0.095805,0.033756,-0.003882,0.030472,-0.062096,-0.042174,-0.050854,-0.016142,0.018140,-0.079300,-0.052260,-0.092418,-0.032884,0.040167,0.134180,0.069076,0.085905,0.034646,0.025773,-0.003054,-0.019341,-0.015868,-0.070494,-0.025843,-0.042265,0.046173,0.057486,0.103321,0.058056,-0.021250,0.005307,-0.119438,-0.045100,-0.016288,0.018936,0.126550,0.056904,0.073561,0.017747,-0.018481,-0.139257,-0.092248,-0.029884,-0.011082,0.029468,0.141461,0.052897,-0.020906,-0.027590,-0.069780,-0.026940,-0.037226,0.023920,0.093520,0.053490,-0.040158,-0.085819,-0.104926,-0.103472,0.015459,0.038334,0.074526,0.062430,-0.047330,0.043827,0.057143,0.052226,-0.089994,-0.035397,-0.012612,0.016116,0.007238,-0.071562,-0.047616,-0.021775,-0.022598,-0.082854,0.000779,0.057219,0.043477,-0.003371,-0.063407,-0.102996,-0.028898,0.000510,-0.029477,0.032158,0.103479,0.120826,0.039458,0.016087,0.085317,0.086201,0.131181,-0.001986,-0.062167,-0.011557,-0.003294,0.007830,0.030850,-0.048823,-0.065754,-0.029885,-0.113016,0.006440,-0.006796,0.005563,0.039552,0.168955,-0.009768,-0.052855,-0.000852,-0.056551,0.010834,-0.003565,0.070441,0.164160,0.120922,0.070770,0.037562,0.078159,-0.123440,-0.140317,-0.103445,-0.092943,0.007258,0.080988,0.011395,-0.076777,0.022546,-0.035317,-0.053463,-0.039132,-0.026387,0.126318,0.068243,-0.038906,-0.028777,0.027334,0.039678,-0.014356,-0.073756,-0.019260,0.097310,-0.028889,-0.043863,-0.012305,0.094843,0.143576,0.119369,-0.014083,0.009775,0.001580,0.076439,-0.032141,-0.085754,-0.003773,-0.042928,-0.067247,-0.067403,-0.035572,0.087313,0.059396,0.070081,0.041330,0.185174,0.075576,-0.055546,-0.094650,-0.050182,-0.022831,0.033576,-0.014416,-0.049663,-0.058342,-0.022962,0.074651,0.049014,0.111198,0.141773,0.108237,-0.012218,-0.045043,-0.062054,-0.053872,0.000870,0.001621,0.073967,0.119276,-0.040191,-0.048971,-0.059311,-0.048155,-0.047775,-0.013645,-0.010767,0.018396,-0.002081,-0.075930,-0.076808,-0.106607,-0.080176,-0.082534,-0.018192,-0.009615,-0.023730,-0.000458,0.059786,0.003190,-0.036214,-0.037003,0.032630,0.009696,-0.015911,0.017935,0.064133,-0.036004,-0.050594,-0.096230,-0.084881,0.047249,0.056943,0.061120,0.046850,0.027098,-0.085720,-0.060415,-0.067734,0.002715,0.050310,0.070854,0.024693,0.018515,-0.019691,-0.079369,-0.048973,-0.034463,0.040693,0.132943,0.121773,0.048109,0.001961,-0.028908,-0.071378,-0.090946,-0.071086,-0.000537,0.047173,0.047281,0.037003,0.037911,0.017214,-0.016783,-0.013305,0.032561,0.145203,0.085545,-0.065811,-0.089528,-0.079666,-0.028957,-0.033680,-0.043741,-0.030335,0.104342,0.145611,0.096378,0.023457,-0.012553,-0.008646,0.009611,-0.005878,-0.026409,0.065878,0.093207,0.113093,0.003727,-0.021256,0.023918,0.053303,-0.002744,0.023011,0.131815,0.050346,-0.064833,-0.079512,-0.079638,-0.036684,0.062233,0.011493,-0.000057,0.053080,0.005609,0.004425,-0.018753,-0.020624,0.079997,-0.013700,-0.029706,-0.009604,0.090969,0.031114,0.076745,-0.003245,-0.038770,-0.024424,-0.037444,0.031432,0.039634,0.098753,0.008367,0.091997,0.003694,-0.046439,0.004013,0.100107,-0.001315,-0.031796,0.016487,-0.078866,-0.018696,-0.016033,0.011498,0.085405,0.131068,0.092526,0.130904,0.117100,-0.061847,-0.053783,-0.048746,-0.020535,0.023317,-0.008174,0.012856,0.007219,0.067545,-0.094512,-0.010841,-0.030869,-0.049089,-0.017596,-0.090146,-0.020915,-0.030602,0.003473,-0.075948,-0.026321,-0.041912,-0.045370,-0.070439,-0.060400,-0.047181,-0.046365,-0.027407,0.039582,0.008280,0.021274,-0.005860,-0.027773,-0.059154,-0.032047,-0.067912,-0.065017,-0.033072,0.041278,0.029864,0.032107,0.004642,-0.057505,-0.069860,-0.048215,-0.056548,0.022161,-0.000420,0.000348,-0.001994,-0.008491,-0.042508,-0.021704,-0.017374,-0.094084,-0.073724,-0.000184,-0.027260,-0.037317,-0.004721,-0.127653,-0.058439,-0.032330,0.016534,0.070679,0.099368,0.068370,0.016858,-0.058790,-0.011510,-0.055876,0.007167,0.078766,0.163907,0.149232,0.064546,-0.000592,0.046019,-0.038163,-0.032316,-0.031174,-0.072286,-0.032153,0.032444,-0.037128,-0.058424,-0.041128,0.022210,-0.042770,-0.024302,-0.060940,0.051812,0.103058,0.066674,0.033556,0.039460,0.036262,-0.019778,-0.002395,0.045228,0.064831,0.085310,0.005558,-0.031724,0.020221,0.054600,0.063735,0.023632,0.077738,0.065457,0.082648,0.016696,-0.036066,-0.032122,0.136515,-0.013116,-0.040740,-0.059184,-0.044057,0.042540,0.028787,0.052706,0.128368,0.136611,0.096668,0.038638,0.071638,-0.074222,-0.037324,0.003004,0.029130,0.074784,0.062653,0.084864,0.054239,0.136682,0.074407,0.075828,0.026817,-0.049344,-0.098002,-0.050031,0.043709,0.016652,0.085217,0.013572,0.063780,-0.000996,-0.064357,-0.069863,0.037107,0.057436,0.046988,0.156617,-0.003964,-0.001629,-0.000784,0.008975,-0.053597,0.002663,0.003339,-0.027596,0.005979,-0.140064,-0.036107,-0.046271,-0.068453,-0.042326,0.015923,0.128287,0.099303,0.107498,-0.083149,-0.037610,-0.048452,-0.065666,-0.073769,-0.052328,-0.009728,-0.014688,0.006849,-0.034879,-0.053733,-0.060372,-0.035553,-0.109988,0.068545,0.029440,-0.013455,0.013498,-0.178925,-0.099996,-0.110373,-0.109605,0.009885,0.037769,-0.002000,-0.022974,0.036628,-0.095970,-0.110833,-0.108128,-0.071921,-0.021004,-2.031360};
//空心方框检测参数;
const double g_hRectCoeff_48[n48Size] = { 0.015578,0.027536,0.028241,0.041527,-0.024166,-0.022881,-0.008538,0.003728,0.014375,0.049577,0.025087,0.007594,-0.017894,-0.049462,-0.040552,-0.020686,-0.000388,0.043559,-0.005153,0.003825,0.003764,0.037237,0.008249,0.004420,-0.009984,-0.008487,-0.004555,0.022121,0.030074,0.015784,0.016665,0.011738,-0.028137,-0.027267,-0.011018,0.013786,0.046646,0.000277,-0.011682,-0.016286,-0.047790,-0.024969,-0.021107,-0.003755,0.052771,0.024256,-0.016998,-0.015024,-0.005975,-0.017882,-0.018587,-0.029918,-0.017759,0.025577,0.049215,0.009382,0.001889,-0.003420,-0.014613,-0.026589,-0.022847,-0.007360,0.032358,0.039169,-0.016051,-0.017827,-0.017826,-0.031230,-0.027417,-0.030631,-0.022628,0.026614,0.028333,-0.009251,-0.008365,-0.004869,-0.016004,-0.018405,-0.028315,-0.021370,0.024242,0.029698,-0.004720,-0.007233,-0.006060,-0.020584,-0.023374,-0.034104,-0.034077,0.025775,0.040996,-0.014754,-0.019031,-0.018803,-0.026898,-0.034362,-0.035583,-0.032638,0.032534,0.047930,-0.021516,-0.021470,-0.032003,-0.037922,-0.044382,-0.050158,-0.045452,0.042179,0.042750,-0.003628,-0.009895,-0.015499,-0.026282,-0.027831,-0.033273,-0.025580,0.039152,0.037120,0.005306,-0.012619,-0.015919,-0.033019,-0.037905,-0.023759,0.001006,0.046110,0.046212,-0.021670,-0.024430,-0.034876,-0.041751,-0.038707,-0.032320,-0.017323,0.051361,0.020169,-0.020961,-0.032155,-0.036646,-0.022778,-0.012481,0.006231,0.014840,0.057097,0.027071,0.010112,-0.000031,-0.004826,-0.021686,-0.012976,0.003794,0.027001,0.035670,0.000984,-0.002399,-0.004725,-0.000356,-0.011127,0.021256,0.008612,0.018619,0.005764,-0.010631,-0.013718,-0.020795,-0.013936,0.012865,0.018861,0.021340,0.019846,0.006893,-0.032509,-0.025872,-0.028912,0.012094,0.004610,0.024524,0.004066,-0.005843,-0.035677,-0.009864,-0.006168,-0.014116,0.009320,0.038020,0.005966,-0.011688,-0.008220,-0.006584,-0.017182,-0.001467,-0.009796,0.014850,0.047170,-0.025363,-0.028757,-0.016633,-0.010336,-0.009144,-0.006838,-0.021838,-0.014338,0.031455,-0.002154,-0.014306,-0.011036,-0.008775,-0.022381,-0.010250,-0.031584,-0.008903,0.037309,-0.033368,-0.029554,-0.019792,-0.018163,0.023242,0.016712,0.016847,0.032268,0.040547,-0.013818,-0.016604,-0.006344,-0.003460,0.040047,0.007934,-0.001376,0.000142,-0.030072,-0.015629,-0.016679,-0.013744,0.003540,-0.016471,-0.008719,-0.014804,0.017983,0.030884,-0.019427,-0.018339,-0.011250,-0.019823,-0.014265,-0.012769,-0.012731,0.004817,-0.024839,-0.016488,-0.019923,-0.018226,-0.027083,0.066599,0.008123,-0.006019,-0.015620,-0.016820,-0.020090,-0.016400,-0.015041,0.050284,0.068183,-0.001622,-0.010703,-0.033483,-0.031641,-0.036389,-0.018951,0.002678,0.066993,-0.011545,-0.011063,-0.001890,-0.007849,-0.019890,-0.009430,-0.015508,-0.019840,-0.021329,-0.011447,-0.008291,-0.012405,-0.035678,-0.034212,-0.013565,-0.009390,-0.004828,-0.013450,0.019064,-0.011473,-0.014313,-0.024112,-0.035539,-0.012397,-0.009357,0.007664,0.052820,-0.008787,-0.017743,-0.019243,-0.025175,0.042555,0.042787,0.017517,0.006835,0.019018,-0.018009,-0.020189,-0.023381,-0.028333,-0.018302,-0.004005,-0.012153,-0.011056,-0.031105,-0.034234,-0.039090,-0.036382,-0.019050,0.035018,0.036203,-0.010463,-0.027277,-0.033980,-0.020756,-0.017595,-0.017193,-0.018602,0.052412,0.033000,-0.002336,-0.013021,-0.023004,-0.029299,-0.023714,-0.026126,0.000692,0.040862,0.005280,-0.022876,-0.022363,-0.038358,-0.024515,-0.035116,-0.027800,-0.016462,0.046079,0.021345,-0.025279,-0.029327,-0.028139,-0.034339,-0.029811,-0.019310,-0.018532,0.038165,-0.007659,-0.033298,-0.026958,-0.039353,-0.009623,-0.005834,-0.022704,-0.014320,0.046214,-0.000289,-0.014154,-0.014257,-0.011894,-0.025293,-0.009116,-0.039502,-0.019820,0.048078,-0.022436,-0.028040,-0.025787,-0.025742,-0.017466,-0.014521,-0.027265,-0.006120,0.043011,-0.004958,-0.015852,-0.013946,-0.016891,-0.033541,-0.015779,-0.035165,-0.012071,0.045989,-0.021567,-0.033146,-0.033036,-0.026466,-0.019954,-0.012932,-0.020681,0.009800,0.054097,-0.010595,-0.021015,-0.015881,-0.022665,-0.020157,-0.017895,-0.019018,-0.006394,0.011163,-0.011785,-0.021254,-0.022392,-0.023188,-0.031736,-0.016142,-0.022660,-0.002553,0.057175,0.003751,-0.021154,-0.021095,-0.028784,-0.028557,-0.024963,-0.028189,-0.026244,0.014399,0.007208,-0.012972,-0.017436,-0.026711,-0.011388,-0.012824,0.001965,0.004094,0.025503,0.004540,-0.011391,-0.023629,-0.012512,-0.009465,-0.006872,-0.012956,-0.022333,0.021269,0.008393,-0.004736,-0.012209,-0.014087,-0.019763,-0.023401,-0.024572,-0.010199,0.031426,0.020553,0.005722,-0.015155,-0.011311,-0.013647,-0.003999,-0.014128,-0.003183,0.030138,0.008654,-0.011330,-0.019140,-0.016385,-0.014439,-0.018105,-0.023046,-0.020329,0.019019,0.001506,-0.033676,-0.020981,-0.030472,-0.035805,-0.043373,-0.038772,0.006221,0.072944,0.023703,-0.022639,-0.020951,-0.032909,-0.018858,-0.015252,-0.032833,-0.007980,0.030555,-0.011294,-0.039204,-0.023473,-0.031413,-0.032481,-0.036023,-0.043989,0.021396,0.073110,0.002218,-0.031596,-0.023759,-0.035125,-0.033476,-0.041378,-0.030575,-0.007711,0.062772,0.006647,-0.022763,-0.019061,-0.025096,-0.039027,-0.040207,-0.033402,-0.026974,0.051492,0.002672,-0.026264,-0.018968,-0.030383,-0.032260,-0.036334,-0.040940,-0.005629,0.066437,-0.000796,-0.024293,-0.016948,-0.026428,-0.037767,-0.034923,-0.050439,-0.016911,0.054519,0.005257,-0.032541,-0.016826,-0.027958,-0.013408,-0.014411,-0.015738,-0.002380,0.041675,-0.011267,-0.015142,-0.008943,-0.016824,-0.034599,-0.011703,-0.018611,-0.024194,0.039369,-0.007305,-0.025794,-0.016804,-0.033269,-0.015391,-0.008874,-0.015538,0.011163,0.039029,0.000338,-0.015578,-0.008927,-0.018436,-0.033110,-0.008747,-0.025620,-0.033383,0.031504,0.010357,-0.003376,-0.005001,-0.026795,-0.028283,-0.005381,-0.006472,-0.008029,0.046679,0.017087,-0.012543,-0.008646,-0.024506,-0.032829,-0.015652,-0.009766,-0.011972,-0.006371,0.005419,-0.010060,-0.008441,-0.023993,-0.012076,-0.006812,-0.006536,-0.019524,0.033357,0.025153,0.020176,0.021062,0.016760,0.008912,-0.017459,-0.006024,-0.020903,-0.039012,-0.007788,-0.006759,0.004023,0.034374,-0.040714,-0.021333,-0.012983,-0.009529,-0.005272,-0.005678,-0.012064,-0.016872,-0.034774,-0.019828,-0.013260,-0.018468,-0.014745,-0.008482,-0.015059,-0.024800,-0.026512,-0.024129,0.044822,-0.016109,-0.014097,-0.026744,-0.016546,-0.017451,-0.018235,-0.007883,0.047995,0.067641,-0.007141,-0.013589,-0.027554,-0.023995,-0.019895,-0.021098,-0.024619,0.054440,-0.026259,-0.013895,-0.020056,-0.001897,0.002240,-0.020928,-0.028971,-0.022898,-0.030605,-0.035551,-0.026837,-0.029497,0.027575,0.045341,-0.023336,-0.028030,-0.020480,-0.041535,0.043802,0.002271,-0.008900,-0.001133,-0.023904,-0.016156,-0.017046,-0.021824,0.003698,0.012460,0.011212,0.004691,0.043720,0.029174,-0.033744,-0.028200,-0.030141,-0.022616,-0.035554,-0.024149,-0.027259,0.012593,0.053337,-0.009444,-0.020141,-0.015454,-0.030249,-0.047517,-0.028036,-0.035858,-0.004381,0.043623,0.014109,-0.015871,-0.012093,-0.030700,-0.028280,-0.017646,-0.020817,0.024687,0.049297,-0.017542,-0.022804,-0.023006,-0.035907,-0.048170,-0.038849,-0.039117,0.012283,0.049855,0.024831,-0.016903,-0.023034,-0.039169,-0.006217,0.003009,-0.003926,0.012019,0.011650,0.034670,0.002736,0.002623,-0.003235,-0.001869,0.001403,-0.017719,-0.015708,-0.006192,-0.007977,0.002899,0.008720,0.006684,0.040884,0.020105,-0.006575,-0.010837,-0.011785,0.041538,0.011837,0.022671,0.035733,0.042394,0.007287,-0.023264,-0.033818,-0.043187,-0.030189,-0.016887,0.012681,0.042425,0.017408,-0.004822,-0.008846,-0.015245,-0.022439,-0.019689,-0.002050,0.009134,0.041571,0.019414,-0.014375,-0.013820,-0.022232,-0.044201,-0.031020,-0.024028,-0.014253,0.028677,0.031722,-0.003878,-0.013281,-0.013539,-0.043035,-0.035031,-0.019258,-0.002999,0.036968,0.029561,-0.008981,-0.008771,-0.009976,-0.030562,-0.022765,-0.031276,-0.023045,0.018297,0.021874,-0.020194,-0.017246,-0.021630,-0.026105,-0.020425,-0.027595,-0.021484,0.031129,0.033599,-0.032818,-0.026843,-0.024560,-0.027896,-0.016809,-0.021798,-0.026028,0.032523,0.015964,-0.015496,-0.011540,-0.013261,-0.028638,-0.019518,-0.021830,-0.025630,0.010825,0.020428,-0.031698,-0.024640,-0.016031,-0.028201,-0.020029,-0.015370,-0.019523,0.019034,0.049531,-0.015442,-0.029718,-0.017095,-0.031172,-0.018907,-0.021692,-0.028572,0.018298,0.037398,0.019416,-0.008687,0.009087,-0.015274,-0.034060,-0.026406,-0.026294,-0.001559,0.020546,-0.028751,-0.033428,-0.018147,-0.029251,-0.019449,-0.017722,-0.024165,0.025750,0.031588,0.000190,-0.019813,-0.013873,-0.034710,-0.019672,-0.015019,-0.007711,0.034014,-0.004891,0.005212,-0.000361,0.021563,0.012527,-0.015921,-0.018424,-0.008749,-0.009799,-0.033092,-0.027280,-0.022460,0.036488,0.030084,0.003312,-0.016108,-0.017358,-0.023394,0.035000,0.015518,0.001986,0.002570,-0.027030,-0.014765,-0.006360,0.013876,0.022986,0.007596,-0.009694,0.007099,0.036813,0.006965,-0.020455,-0.015638,0.004521,0.017527,-0.588226};
//实心方框检测参数;
const double g_sRectCoeff_48[n48Size] = { 0.029607,0.048071,0.038787,0.047909,-0.013389,-0.025042,-0.019144,-0.019765,-0.022918,0.035730,0.008240,-0.009077,-0.020738,-0.042424,-0.033242,-0.033422,-0.036150,0.030632,-0.001003,0.009339,0.010000,0.043011,0.020286,-0.003258,-0.012028,-0.012499,-0.013396,0.010586,-0.000172,-0.017568,-0.016240,0.005264,-0.017415,-0.025434,-0.019363,-0.009296,0.050049,-0.012593,-0.022792,-0.016583,-0.039763,-0.021296,-0.026352,-0.027441,0.056787,0.031635,-0.028582,-0.019934,-0.006406,-0.020420,-0.022535,-0.030934,-0.032103,0.036977,0.024321,-0.019641,-0.024816,-0.029454,-0.041077,-0.022463,-0.021057,-0.015701,0.012177,0.012189,-0.028801,-0.025728,-0.016895,-0.040066,-0.032559,-0.029452,-0.024779,0.007941,0.037095,-0.015451,-0.011898,-0.005929,-0.016285,-0.019709,-0.029025,-0.032029,0.038977,0.035141,-0.013764,-0.010643,-0.009793,-0.025464,-0.021541,-0.033454,-0.044600,0.036484,0.006300,-0.015720,-0.023569,-0.016371,-0.030336,-0.031208,-0.030808,-0.026799,0.001432,0.016394,-0.017691,-0.020534,-0.028683,-0.037975,-0.031456,-0.038141,-0.041004,0.007144,0.051547,-0.008608,-0.010450,-0.016248,-0.030170,-0.026676,-0.031980,-0.031435,0.052870,0.044615,-0.013303,-0.012017,-0.014698,-0.034732,-0.037275,-0.036993,-0.020503,0.059498,0.018082,-0.019948,-0.021337,-0.030534,-0.038429,-0.031875,-0.035772,-0.032427,0.011563,0.019997,-0.023869,-0.023181,-0.029535,-0.047414,-0.043444,-0.030660,-0.025813,0.031831,0.022356,-0.018132,-0.011219,-0.013007,-0.020713,-0.010243,-0.003890,0.016406,0.048949,-0.041960,-0.030623,-0.018641,-0.017832,0.002348,0.040428,0.022493,0.043279,0.016375,-0.014899,-0.026849,-0.021830,-0.018848,0.007077,0.000777,-0.006201,-0.006089,0.004704,-0.045310,-0.033434,-0.032286,-0.009126,0.027220,0.038937,0.006781,0.002835,-0.030611,-0.015293,-0.004911,-0.005876,0.023977,0.055809,0.011285,-0.007161,-0.005576,-0.009558,-0.039591,-0.010183,-0.022412,-0.018174,0.021505,-0.005682,-0.026465,-0.015799,-0.031424,-0.018397,-0.009851,-0.018977,0.014632,0.052742,0.018024,-0.005217,-0.004689,-0.017513,-0.034374,-0.005639,-0.025126,-0.012494,0.021284,-0.009198,-0.022666,-0.013735,-0.037804,0.007413,0.008342,0.002362,-0.013096,-0.011723,0.003358,0.001579,0.012248,0.002256,0.005082,0.001809,-0.008305,-0.011343,-0.040693,-0.015001,-0.010459,0.001435,-0.003222,0.007366,0.019879,-0.001186,-0.015006,-0.009591,0.003816,0.015146,0.020179,-0.001611,0.016110,0.001238,-0.015864,-0.023973,-0.052339,-0.007757,-0.006193,0.006071,0.004825,-0.000989,0.006643,-0.012155,-0.017824,-0.031811,-0.018998,-0.011720,0.002169,-0.009222,0.006480,0.016326,-0.010188,-0.026712,-0.032783,-0.024509,-0.016695,-0.002792,-0.003501,0.006812,0.002701,-0.012137,-0.025846,-0.037588,-0.004668,-0.007970,0.007155,0.003326,0.016063,0.025045,-0.010153,-0.036723,-0.041132,-0.019512,-0.012835,0.009014,0.004881,0.004754,0.007213,-0.007114,-0.017671,-0.030160,-0.016867,-0.017725,-0.006116,0.005156,0.000358,0.004325,0.008745,-0.005050,0.005352,-0.004643,-0.007748,-0.008689,0.007705,0.017111,0.014116,-0.011277,-0.026025,-0.040313,-0.018699,-0.014496,0.010699,0.003697,0.010414,0.001006,0.002044,-0.004919,-0.018268,-0.007299,0.000567,0.008006,0.010828,-0.029808,-0.019002,-0.013860,-0.012635,0.028946,-0.001034,-0.015952,-0.021570,-0.027343,-0.039486,-0.024618,-0.024522,-0.004420,0.066688,0.021679,-0.025535,-0.029090,-0.044639,-0.034755,-0.028074,-0.017510,-0.001597,0.033728,-0.004590,-0.018099,-0.020880,-0.034442,-0.048369,-0.026960,-0.015584,0.002166,0.066284,0.007209,-0.022767,-0.024939,-0.047825,-0.014611,-0.005904,-0.015747,0.020456,0.062335,0.023127,-0.005604,-0.006731,-0.014890,-0.032390,-0.003343,-0.025786,-0.011788,0.018620,-0.006080,-0.019581,-0.015269,-0.030984,-0.026360,-0.020957,-0.026782,0.024318,0.055999,0.025925,-0.010269,-0.007795,-0.022535,-0.055444,-0.026613,-0.043287,-0.009007,0.023174,-0.020783,-0.031875,-0.021529,-0.035656,0.014322,0.023043,0.000748,-0.014487,-0.018444,-0.016213,-0.005844,0.012025,0.008201,0.016490,0.002227,-0.018768,-0.029694,-0.042976,-0.013917,-0.017643,0.004441,0.013807,0.004231,0.001352,-0.017901,-0.019506,-0.019999,-0.028534,-0.014303,0.022410,0.021779,0.014270,-0.005571,-0.032252,-0.040698,-0.052071,-0.024557,-0.022158,0.007477,0.020322,0.008794,-0.002931,-0.015880,-0.029794,-0.030585,-0.009676,-0.020935,-0.001597,0.011925,0.015476,0.007659,-0.020104,-0.041539,-0.033824,-0.019100,-0.023701,0.010364,0.018325,0.007695,-0.011340,-0.033361,-0.033459,-0.036882,-0.016943,-0.029721,-0.002914,0.018537,0.015801,-0.003199,-0.035311,-0.037316,-0.035799,-0.020308,-0.040447,-0.002755,0.022555,0.019487,0.011606,-0.016307,-0.023051,-0.025909,-0.014753,-0.024534,0.013630,0.017924,0.005925,-0.006068,-0.019897,-0.002224,-0.011565,-0.009410,-0.004954,0.022612,0.016346,0.020922,0.005409,-0.033192,-0.034282,-0.031996,-0.020589,-0.030173,0.008338,0.012062,0.015704,0.005705,-0.022347,-0.023723,-0.008497,-0.008257,-0.006774,0.018183,0.007239,-0.037304,-0.034774,-0.024641,0.005092,0.038736,-0.003489,-0.011846,-0.008774,-0.027103,-0.043885,-0.037841,-0.028898,0.011905,0.082330,0.011324,-0.015891,-0.014623,-0.037278,-0.040981,-0.033936,-0.035260,-0.008981,0.044089,0.000988,-0.019525,-0.016531,-0.035672,-0.050385,-0.045963,-0.044921,0.020927,0.084975,0.016210,-0.027849,-0.033697,-0.039693,-0.021622,-0.016553,-0.019067,0.012952,0.061503,0.024102,-0.011918,-0.007063,-0.021367,-0.050283,-0.017198,-0.025934,-0.017471,0.021000,-0.015433,-0.030793,-0.015393,-0.036382,-0.018042,-0.009011,-0.016169,0.007384,0.060110,0.040737,-0.007367,-0.006380,-0.015069,-0.047466,-0.015822,-0.030644,-0.024895,0.009351,-0.021345,-0.032272,-0.019035,-0.038413,-0.006479,0.005831,0.004756,0.000148,-0.003409,-0.017093,-0.014538,0.005197,0.003877,0.000465,0.001507,-0.003779,-0.015671,-0.037732,-0.022568,-0.016266,-0.002835,-0.005797,0.005484,-0.004660,-0.004944,-0.002080,0.006380,-0.017082,-0.008447,0.007938,0.005752,0.002024,0.006289,0.000100,-0.013924,-0.039065,-0.020763,-0.012380,-0.008888,-0.006109,-0.014899,-0.000377,-0.004143,-0.012197,-0.026635,-0.014620,-0.021549,-0.004359,-0.021896,-0.002456,-0.002749,-0.014682,-0.017181,-0.023811,-0.016718,-0.031742,-0.004214,0.014482,-0.010537,0.010455,0.000666,-0.019086,-0.035636,-0.015555,-0.020368,-0.010372,-0.022043,0.001490,-0.004795,-0.005217,-0.022407,-0.029167,-0.017049,-0.019371,-0.006988,0.004134,0.009216,-0.008986,-0.026211,-0.028355,-0.031068,-0.019005,-0.022340,0.002517,0.010721,0.017651,0.001853,-0.023450,-0.029284,-0.023041,-0.014079,-0.000952,0.017737,0.004482,0.009646,-0.018644,-0.014733,-0.015906,-0.029093,-0.012467,-0.010236,-0.001955,0.016860,0.017503,0.001847,-0.009088,-0.016827,-0.008908,-0.016907,-0.006553,-0.000341,0.017977,-0.030070,-0.017023,-0.024148,-0.017245,0.019468,-0.005804,-0.023511,-0.016005,-0.035036,-0.046119,-0.030809,-0.032116,0.017345,0.068550,0.012926,-0.015183,-0.022473,-0.038807,-0.023602,-0.012565,-0.029131,-0.018693,0.023969,-0.013987,-0.025895,-0.019060,-0.031476,-0.037799,-0.025870,-0.024531,0.036649,0.070959,0.012780,-0.014196,-0.024272,-0.036138,-0.014905,-0.013856,-0.015497,-0.005626,0.022827,0.049995,0.010216,0.007400,0.003670,-0.014848,-0.025324,-0.033120,-0.022228,-0.026100,-0.030138,-0.034536,-0.014199,-0.001931,0.003215,-0.011916,-0.018368,-0.019380,-0.000748,0.056198,0.036834,0.051693,0.047971,0.035210,-0.023279,-0.030199,-0.027336,-0.038446,-0.020123,-0.016513,0.019960,0.037566,0.003196,-0.021105,-0.018028,-0.014744,-0.046129,-0.038809,-0.031943,-0.022404,0.004070,0.004037,-0.016279,-0.011182,-0.019562,-0.047345,-0.032245,-0.024433,-0.030518,-0.005432,0.047061,-0.020689,-0.015499,-0.012107,-0.038203,-0.026960,-0.023665,-0.013137,0.050772,0.040576,-0.014349,-0.010296,-0.009579,-0.031803,-0.017380,-0.023666,-0.028509,0.034433,-0.002184,-0.013895,-0.010610,-0.018624,-0.036511,-0.018444,-0.022245,-0.026185,-0.007186,0.008089,-0.038849,-0.022687,-0.019830,-0.036832,-0.017032,-0.022105,-0.027397,0.005376,0.037007,-0.015717,-0.012185,-0.011956,-0.032477,-0.016886,-0.014577,-0.024546,0.029666,0.040242,-0.034931,-0.023653,-0.012948,-0.032141,-0.019109,-0.012145,-0.020822,0.037776,0.012346,-0.043689,-0.034897,-0.017763,-0.030823,-0.018290,-0.023128,-0.030467,0.003325,0.023697,-0.034909,-0.038698,-0.024210,-0.034548,-0.028538,-0.028388,-0.030589,0.013000,0.040424,-0.037484,-0.030705,-0.015735,-0.028289,-0.017645,-0.016812,-0.029191,0.041910,0.053903,-0.015708,-0.026997,-0.014683,-0.037563,-0.019944,-0.018742,-0.025405,0.044583,0.011137,-0.004534,-0.020527,-0.003368,-0.002204,-0.023611,-0.027882,-0.019843,-0.011159,-0.016539,-0.001936,-0.010844,0.050387,0.037483,-0.018499,-0.023960,-0.023880,-0.029691,0.047353,0.019617,-0.003538,-0.003103,-0.039736,-0.026839,-0.020122,-0.011988,0.023061,0.023070,0.036478,0.020727,0.038449,0.007374,-0.036718,-0.028976,-0.016094,-0.029331,-0.230698 };


CMarkerFinder::CMarkerFinder()
{
}


CMarkerFinder::~CMarkerFinder()
{

}

//y坐标的比较;
bool VecCmp_H(Vec<int, 5> a1, Vec<int, 5> a2) {
	return a1.val[1] < a2.val[1];
}

//x坐标的比较;
bool VecCmp_V(Vec<int, 5> a1, Vec<int, 5> a2) {
	return a1.val[0] < a2.val[0];
}

//nScale 缩放比例;霍夫变换找到的直线很多很接近，需要进一步处理，去掉一些多余的很接近的线;
void ReArrangeVector_H(vector<Vec<int, 5>> &vecLines, int nScale) {

	vector<Vec<int, 5>> newVector;
	int nSize = vecLines.size();

	//只有一条线的话，直接返回，不处理;
	if (nSize == 1)
		return;

	for (int i = 0; i < nSize - 1; i++)
	{
		Vec<int, 5> t0 = vecLines[i];
		Vec<int, 5> t1 = vecLines[i + 1];

		//找连续的靠的非常近的直线;
		int nStart = i;
		while (vecLines[i + 1].val[1] - vecLines[i].val[1] < 20 * nScale)
			if (i + 1 < nSize)
				i++;
		//一共有几条很近的直线
		int nGap = i - nStart;

		if (nGap == 0)
			newVector.push_back(t0);
		//两条很接近的线,取其均值;
		else if (nGap == 1)
		{
			Vec<int, 5> t;
			t.val[0] = t0.val[0];
			t.val[1] = (t0.val[1] + t1.val[1]) / 2;  //y坐标均值;
			t.val[2] = t0.val[2];
			t.val[3] = (t0.val[3] + t1.val[3]) / 2;  //y坐标均值;
			t.val[4] = t0.val[4];
			newVector.push_back(t);
		}
		//多条很接近的线;
		else
		{
			int nMiddle = nStart + (nGap + 1) / 2;
			newVector.push_back(vecLines[nMiddle]);
		}
	}

	//将最终结果写回;
	vecLines.clear();
	for (int i = 0; i < newVector.size(); i++)
		vecLines.push_back(newVector[i]);
}

//nScale 缩放比例;
void ReArrangeVector_V(vector<Vec<int, 5>> &vecLines, int nScale) {

	vector<Vec<int, 5>> newVector;
	int nSize = vecLines.size();

	//只有一条线的话，直接返回，不处理;
	if (nSize == 1)
		return;

	for (int i = 0; i < nSize - 1; i++)
	{
		Vec<int, 5> t0 = vecLines[i];
		Vec<int, 5> t1 = vecLines[i + 1];

		//找连续的靠的非常近的直线;
		int nStart = i;
		while (((vecLines[i + 1].val[0] - vecLines[i].val[0]) < 20 * nScale) && (i + 1 < nSize))
		{
			i++;
		}
		//一共有几条很近的直线
		int nGap = i - nStart;

		if (nGap == 0)
			newVector.push_back(t0);
		//两条很接近的线,取其均值;
		else if (nGap == 1)
		{
			Vec<int, 5> t;
			t.val[0] = (t0.val[0] + t1.val[0]) / 2;
			t.val[1] = t0.val[1];  //y坐标均值;
			t.val[2] = (t0.val[2] + t1.val[2]) / 2;
			t.val[3] = t0.val[3];  //y坐标均值;
			t.val[4] = t0.val[4];
			newVector.push_back(t);
		}
		//多条很接近的线;
		else
		{
			int nMiddle = nStart + (nGap + 1) / 2;
			newVector.push_back(vecLines[nMiddle]);
		}
	}

	//将最终结果写回;
	vecLines.clear();
	for (int i = 0; i < newVector.size(); i++)
		vecLines.push_back(newVector[i]);
}

//霍夫变换生成的坐标，很可能超出图像边界的。
//根据这些坐标，计算从上到下的直线，或者从左到右的直线的坐标;
void RecalPoint(Point &p1, Point &p2, int nHeight, int nWidth, int nAngle) {
	Point newP1, newP2;
	float f = (p1.y - p2.y) * 1.0 / (p1.x - p2.x);

	//垂直的线;
	if (nAngle < 45 || nAngle > 270 + 45) {
		newP1.y = 0;
		newP1.x = p1.x - (p1.y - newP1.y) / f;
		newP2.y = nHeight - 1;
		newP2.x = p1.x - (p1.y - newP2.y) / f;
	}
	//水平的线
	else
	{
		newP1.x = 0;
		newP1.y = p1.y - (p1.x - newP1.x) * f;
		newP2.x = nWidth - 1;
		newP2.y = p1.y - (p1.x - newP2.x) * f;
	}

	p1 = newP1;
	p2 = newP2;
}

//根据输入的图像,查找图像中的水平/垂直边缘;
bool CMarkerFinder::DetAlignment(Mat srcImage, int &nThre, vector<Vec<int, 5>> & vecFound) {
	if (srcImage.empty())
		return false;

	vecFound.clear();

	Mat resizedImg;  //缩小后处理;
	Mat BImg;        //二值图;
	int nScale = 4;

	resize(srcImage, resizedImg, cvSize(srcImage.cols / nScale, srcImage.rows / nScale));
	Mat kern = getStructuringElement(MORPH_ELLIPSE, Size(3, 3));
	GenerateBImg(resizedImg, BImg);
	dilate(BImg, BImg, kern);

	//对二值图进行膨胀,然后检测Marker区域;
	Mat erodeBImg;
	erode(BImg, erodeBImg, kern);
	subtract(BImg, erodeBImg, BImg);

	Mat tempImg; 
	tempImg = BImg;

	vector<Vec2f> lines;
	// 这里注意第五个参数，表示阈值，阈值越大，表明检测的越精准，速度越快，得到的直线越少（得到的直线都是很有把握的直线）
	//这里得到的lines是包含rho和theta的，而不包括直线上的点，所以下面需要根据得到的rho和theta来建立一条直线
	HoughLines(tempImg, lines, 1, CV_PI / 180, nThre);//注意第五个参数，为阈值
	while (lines.size() > 500){
		nThre = nThre + 100;
		HoughLines(tempImg, lines, 1, CV_PI / 180, nThre);
	}
	while (lines.size() > 50)
	{
		nThre = nThre + (lines.size() / 100 + 1) * 10; //如果数量过多,则每次加的阈值增量更大;
		lines.clear();
		tempImg = BImg;
		HoughLines(tempImg, lines, 1, CV_PI / 180, nThre);
	}
	while (lines.size() == 0)
	{
		nThre -= 10;
		lines.clear();
		tempImg = BImg;
		HoughLines(tempImg, lines, 1, CV_PI / 180, nThre);
	}

	vector<Vec<int, 5>> FinalLines_H, FinalLines_V;
	for (size_t i = 0; i < lines.size(); i++)
	{
		float rho = lines[i][0]; //就是圆的半径r
		float theta = lines[i][1]; //就是直线的角度
		Point pt1, pt2;
		double a = cos(theta), b = sin(theta);
		double x0 = a*rho, y0 = b*rho;
		pt1.x = cvRound(x0 + 1000 * (-b)) * nScale;
		pt1.y = cvRound(y0 + 1000 * (a))  * nScale;
		pt2.x = cvRound(x0 - 1000 * (-b))  * nScale;
		pt2.y = cvRound(y0 - 1000 * (a))  * nScale;
		int angle = int(theta / CV_PI * 180);

		//cout << "Line " << i << ": x1=" << pt1.x << ", x2=" << pt2.x << endl;

		//垂直的线;
		if (angle < 45 || angle > 270 + 45)
			FinalLines_V.push_back(Vec<int, 5>(pt1.x, pt1.y, pt2.x, pt2.y, angle));
		//水平的线;
		else
			FinalLines_H.push_back(Vec<int, 5>(pt1.x, pt1.y, pt2.x, pt2.y, angle));
	}
	//cout << endl;

	//排序;
	int nSize = FinalLines_H.size();
	std::sort(FinalLines_H.begin(), FinalLines_H.end(), VecCmp_H);
	nSize = FinalLines_V.size();
	std::sort(FinalLines_V.begin(), FinalLines_V.end(), VecCmp_V);

	//处理靠的太近的线段;
	vector<Vec<int, 5>> vecFinal;
	ReArrangeVector_H(FinalLines_H, nScale);
	ReArrangeVector_V(FinalLines_V, nScale);

	nSize = FinalLines_H.size();
	for (int i = 0; i < nSize; i++)
		vecFinal.push_back(FinalLines_H[i]);
	nSize = FinalLines_V.size();
	for (int i = 0; i < nSize; i++)
		vecFinal.push_back(FinalLines_V[i]);

	for (size_t i = 0; i < vecFinal.size(); i++)
	{
		Vec<int, 5> l = vecFinal[i];
		Point pt1, pt2;
		pt1.x = l[0];
		pt1.y = l[1];
		pt2.x = l[2];
		pt2.y = l[3];
		RecalPoint(pt1, pt2, srcImage.rows, srcImage.cols, l[4]);

		//最终图像画面内的直线的坐标;
		Vec<int, 5> newLine;
		newLine.val[0] = pt1.x;
		newLine.val[1] = pt1.y;
		newLine.val[2] = pt2.x;
		newLine.val[3] = pt2.y;
		newLine.val[4] = l[4];
		vecFound.push_back(newLine);
	}
}

//分别表示空心十字图，实心十字图,空心pattern图,实心pattern图;
bool CMarkerFinder::Init(Mat hcMarker, Mat scMarker, Mat hcPattern, Mat scPattern, AlgParam param) {
	//hollow cross
	m_hcHog.blockSize = cvSize(16, 16);
	m_hcHog.blockStride = cvSize(8, 8);
	m_hcHog.cellSize = cvSize(8, 8);
	m_hcHog.winSize = cvSize(48, 48);
	m_hcHog.nlevels = 3;

	vector<float> x;
	for (int i = 0; i < n48Size; i++) {
		//十字
		if (param.nMarkerType == 0)
			x.push_back(g_hcCoeff_48[i]);
		//正方形
		else
			x.push_back(g_hRectCoeff_48[i]);
	}

	if (x.size() == 0)
		return false;

	m_hcHog.setSVMDetector(x);

	//solid cross;
	m_scHog.blockSize = cvSize(16, 16);
	m_scHog.blockStride = cvSize(8, 8);
	m_scHog.cellSize = cvSize(8, 8);
	m_scHog.winSize = cvSize(48, 48);
	m_scHog.nlevels = 3;

	x.clear();
	for (int i = 0; i < n48Size; i++) {
		if (param.nMarkerType == 0)
			x.push_back(g_scCoeff_48[i]);
		else
			x.push_back(g_sRectCoeff_48[i]);
	}
	if (x.size() == 0)
		return false;

	m_scHog.setSVMDetector(x);

	m_hcMarker = hcMarker.clone();
	m_scMarker = scMarker.clone();
	m_hcPattern = hcPattern.clone();
	m_scPattern = scPattern.clone();
	if (m_hcMarker.empty() || m_scMarker.empty())
		return false;
	if (m_hcMarker.channels() == 3)
	{
		cvtColor(m_hcMarker, m_hcMarker, CV_BGR2GRAY);
	}
	if (m_scMarker.channels() == 3)
	{
		cvtColor(m_scMarker, m_scMarker, CV_BGR2GRAY);
	}
	//pattern图会被转化为二值图进行匹配;
	double dThre;
	if (!m_hcPattern.empty()) {
		if (m_hcPattern.channels() == 3)
			cvtColor(m_hcPattern, m_hcPattern, CV_BGR2GRAY);
		dThre = threshold(m_hcPattern, m_hcPattern, 0, 255, THRESH_OTSU);
	}
	if (!m_scPattern.empty()) {
		if (m_scPattern.channels() == 3)
			cvtColor(m_scPattern, m_scPattern, CV_BGR2GRAY);
		threshold(m_scPattern, m_scPattern, 0, 255, THRESH_OTSU);
	}

	m_algParams = param;

	/*
	char msg[256];
	sprintf_s(msg, "d:\\init_%d_%d_%.2f_%d.jpg", param.locpattern_bCheckLastNum,
		param.locpattern_bVerticalNum, param.locpattern_fRatio, param.finetune_nHcMargin);
	string strFile(msg);
	imwrite(strFile, hcPattern);
	*/

	return true;
}

//判断相机是否移动;返回值为判断出的移动的像素个数;
int CMarkerFinder::IsMoving(Mat preImg, Mat curImg,int nThre) {
	Mat diff;
	absdiff(preImg, curImg, diff);

	Mat gray;
	if (diff.channels() == 3)
		cvtColor(diff, gray, CV_BGR2GRAY);
	else
		gray = diff;

	Mat  b;  //二值图;固定阈值;
	threshold(gray, b, nThre, 255, THRESH_BINARY);  //粗调50和细调25，采用不同的参数;
	int nNonZero = countNonZero(b);

	return nNonZero;
}


//默认detector已经load了vector;
//dThre为svm检测时的阈值;
//bHollowCross：true表示检测的是空心十字, false表示检测是实心十字;
//vecFoud表示返回的检测结果;
bool CMarkerFinder::LocateCrossAreaByHog(Mat srcImg, bool bHollowCross, vector<LocMarker> & vecFound) {

	if (bHollowCross && m_hcMarker.empty())
		return false;
	if (!bHollowCross && m_scMarker.empty())
		return false;
	if (srcImg.empty())
		return false;

	int    nScale = 4;
	double dHitThre = m_algParams.loccross_fHcThre;
	//实心十字
	if (!bHollowCross) {
		nScale = 3;  //缩放倍数小一点;
		dHitThre = m_algParams.loccross_fScThre;
	}

	//缩放4倍后进行检测;
	Mat resizeSrcImg;
	resize(srcImg, resizeSrcImg, cvSize(srcImg.cols / nScale, srcImg.rows / nScale));
	Mat graySrcImg;
	if (resizeSrcImg.channels() == 3)
		cvtColor(resizeSrcImg, graySrcImg, CV_BGR2GRAY);
	else
		graySrcImg = resizeSrcImg;

	vector< Rect > detections;
	vector< double > foundWeights;
	if (bHollowCross)
		m_hcHog.detectMultiScale(graySrcImg, detections, foundWeights,dHitThre);
	else
		m_scHog.detectMultiScale(graySrcImg, detections, foundWeights, dHitThre);

	for (int i = 0; i < detections.size(); i++)
	{
		//实心标记检测时，权重过低的不要;经验值;
		/*if (!bHollowCross) {
			if (foundWeights[i] < 0)
				continue;
		}*/

		LocMarker lm;
		lm.rect = detections[i];
		lm.rect.x *= nScale;
		lm.rect.y *= nScale;
		lm.rect.width *= nScale;
		lm.rect.height *= nScale;
		lm.fConfidence = foundWeights[i]; 
		
		vecFound.push_back(lm);
	}
}

//利用梯度生成2值图;
double CMarkerFinder::GenerateBImg(Mat srcImg, Mat & bImg,GRADTYPE gt) {

	Mat gray;
	if (srcImg.channels() == 3)
		cvtColor(srcImg, gray, CV_BGR2GRAY);
	else
		gray = srcImg;

	Mat grad_x, grad_y, grad;
	Mat abs_grad_x, abs_grad_y;

	int scale = 1;
	int delta = 0;
	int ddepth = CV_16S;
	/// 求 X方向梯度
	Sobel(gray, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT);
	/// 求 Y方向梯度
	Sobel(gray, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT);

	convertScaleAbs(grad_x, abs_grad_x);
	convertScaleAbs(grad_y, abs_grad_y);
	addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad);

	Mat input = grad;
	if (gt == GT_X)
		input = abs_grad_x;
	else if (gt == GT_Y)
		input = abs_grad_y;

	//二值化;
	double d = threshold(input, bImg, 0, 255, THRESH_OTSU);

	return d;
}

//查找暗场下的marker
//srcImg & tempImg: 原图和模板图;
//wmp:定位晶片marker时的参数;
//vecLocRect: 返回的定位结果;
bool CMarkerFinder::FindWafterMarkerArea(Mat srcImg, Mat bImg, LocWafterMarkerParam wmp,
										vector<Rect>vecTextLoc, vector<Rect> &vecMarkerAreaRect)
{
	int nSize = vecTextLoc.size();
	if (nSize == 0)
		return false;

	int nExtend = 10;
	for (int i = 0; i < nSize; i++)
	{
		Rect wafterRect;
		//默认maker在文字的左边;
		wafterRect.x = vecTextLoc[i].x - wmp.nDistToText - wmp.nMarkerWidth - nExtend;
		if (wafterRect.x < 0)
			wafterRect.x = 0;
		wafterRect.y = vecTextLoc[i].y;
		wafterRect.width = wmp.nMarkerWidth + nExtend * 2;
		
		int nTextBottom = vecTextLoc[i].y + vecTextLoc[i].height;
		//假设maker的底部坐标和文本坐标差不多。为了稳妥，增加了marker大小的高度;
		int nWafterBtm = nTextBottom + wmp.nMarkerWidth;
		if (nWafterBtm > srcImg.rows)
			nWafterBtm = srcImg.rows - 1;
		wafterRect.height = nWafterBtm - wafterRect.y;

		vecMarkerAreaRect.push_back(wafterRect);
	}

	//如果只有1个marker，还要找第二个;
	if (nSize == 1)
	{
		//缩放后的二值图;
		Mat resizedBImg;
		resize(bImg, resizedBImg, cvSize(bImg.cols / 8, bImg.rows / 8));
		
		//对二值图进行膨胀,然后检测Marker区域;
		Mat dilateBImg;
		Mat kern = getStructuringElement(MORPH_ELLIPSE, Size(3, 3));
		dilate(resizedBImg, dilateBImg, kern);

		//计算垂直投影：
		int h = dilateBImg.rows;
		int w = dilateBImg.cols;
		int * pHist = new int[w];
		memset(pHist, 0, sizeof(int)*w);
		for (int row = 0; row < h; row++)
		{
			for (int col = 0; col < w; col++)
			{
				//假设已有marker区域的左边还有一个marker
				//第二个marker的距离：5*wmp.nDistToText;
				int nMarkerLeft = vecMarkerAreaRect[0].x - 10*wmp.nDistToText - wmp.nMarkerWidth; 
				nMarkerLeft /= 8;
				int nMarkerRight = vecTextLoc[0].x + vecTextLoc[0].width;
				nMarkerRight /= 8;

				//已有marker区域不计算;
				if (col>=nMarkerLeft && col<=nMarkerRight)
					continue;

				char v1 = dilateBImg.at<char>(row, col);
				if (v1 != 0)
					pHist[col]++;
			}
		}

		//寻找candidate maker区域;
		vector<Rect> vecTemp;
		Rect rr;
		for (int k = 0; k < w;)
		{
			int nStart;
			if (pHist[k] > 0) {
				nStart = k;
				//找到第一个非黑点;
				while (pHist[k++]);
				//可能是marker;
				if ((k - nStart) * 8 > 0.7 * wmp.nMarkerWidth)
				{
					rr.x = nStart * 8;  //缩放8倍以后，需要算回原始坐标;
					rr.width = (k - nStart) * 8;
					rr.y = 0;
					rr.height = bImg.rows - 1;
					vecTemp.push_back(rr);

					//rectangle(srcImg, rr, Scalar(255, 255, 255), 8);
				}
			}
			else
				k++;
		}

		delete[] pHist;

		//只有一个区域的话，那就是这个marker;
		if (vecTemp.size() == 1)
		{
			rr = vecTemp[0];
			rr.x -= 30;
			rr.width += 60;
			vecMarkerAreaRect.push_back(rr);
		}
		//多个区域的话，不管是2个还是3个，都是第二个;
		else if (vecTemp.size() > 1)
		{
			rr = vecTemp[1];
			rr.x -= 20;
			rr.width += 40;
			vecMarkerAreaRect.push_back(rr);
		}
	}

	return true;
}

//定位明场/暗场下的pattern.为了加快速度,可以缩小数倍后再匹配;
bool CMarkerFinder::LocatePattern(Mat srcImg, bool bHcPattern,int nMaxCount, vector<LocMarker> & vecFound)
{
	Mat   patternImg;
	float fMatchDegree;
	if (bHcPattern)
	{
		patternImg = m_hcPattern;
		fMatchDegree = m_algParams.locpattern_fHcMatchDegree;
	}
	else
	{
		patternImg = m_scPattern;
		fMatchDegree = m_algParams.locpattern_fScMatchDegree;
	}

	if (patternImg.empty())
		return false;

	Mat resizedTempImg, resizedSrcImg;
	int nScale = 4;
	resize(srcImg, resizedSrcImg, cvSize(srcImg.cols / nScale, srcImg.rows / nScale));
	resize(patternImg, resizedTempImg, cvSize(patternImg.cols / nScale, patternImg.rows / nScale));

	//最多两个,匹配阈值0.5;
	vector<LocMarker> vecRect;
	LocateTemplate(resizedSrcImg, resizedTempImg, bHcPattern,fMatchDegree, nMaxCount, vecRect);

	//暗场图左右两边差异实在太大，无法用delta补充时，采用二阶段定位.
	//此时先检测到一组，然后把该组所在的区域从原图抹掉，再进行第二组检测;
	if (m_algParams.locpattern_bTwoStageLoc && (vecRect.size() == 1))
	{
		//创建一个空区域;
		Mat m = Mat::zeros(cvSize(vecRect[0].rect.width, resizedSrcImg.rows), resizedSrcImg.type());
		Mat newSrcImg = resizedSrcImg.clone();

		Rect r = vecRect[0].rect;
		r.y = 0;
		r.height = resizedSrcImg.rows;
		m.copyTo(newSrcImg(r));   //抹掉检测到的所在区域;
		vector<LocMarker> vecRect1;
		//最多再检测1个;
		LocateTemplate(newSrcImg, resizedTempImg, bHcPattern, fMatchDegree, 1, vecRect1);

		if (vecRect1.size() != 0)
			vecRect.push_back(vecRect1[0]);
	}

	for (int j = 0; j < vecRect.size(); j++)
	{
		vecRect[j].rect.x *= nScale;
		vecRect[j].rect.y *= nScale;
		vecRect[j].rect.width *= nScale;
		vecRect[j].rect.height *= nScale;
		vecFound.push_back(vecRect[j]);
	}

	return true;
}

//通过最后一位数字，验证模板匹配是否合理。
//有时板和片上的编号只差一位数字，非常接近，这时定位容易出错;
//srcImg & tempImg: 原图和模板图;
//fMatchThre:匹配度阈值;
//r: 原图中定位到的匹配区域;
bool CMarkerFinder::CheckLocTemp_ByLastNum(Mat srcImg, Mat tempImg, float fMatchThre, Rect r) {
	float fRatio = m_algParams.locpattern_fRatio;

	//模板中最后一位数字的子区域
	Mat temp2;
	Rect rp;
	if (m_algParams.locpattern_bVerticalNum)
		rp = Rect(0, tempImg.rows * fRatio, tempImg.cols, tempImg.rows*(1 - fRatio));
	else
		rp = Rect(tempImg.cols*fRatio, 0, tempImg.cols*(1 - fRatio), tempImg.rows);
	temp2 = tempImg(rp);

	//检测到的区域,选择其中的最后数字子区域;
	float fRatioSrc = fRatio - 0.1; //保证比模板的区域稍微大一点;
	Mat src1 = srcImg(r);
	Rect rs;
	if (m_algParams.locpattern_bVerticalNum)
		rs = Rect(0, src1.rows*fRatioSrc, src1.cols, src1.rows * (1 - fRatioSrc));
	else
		rs = Rect(src1.cols*fRatioSrc, 0, src1.cols*(1 - fRatioSrc), src1.rows);
	Mat src2 = src1(rs);

	Mat resImg;
	matchTemplate(src2, temp2, resImg, CV_TM_CCOEFF_NORMED); //化相关系数匹配法(最好匹配1)

	double minValue, maxValue;
	Point minLoc, maxLoc;
	minMaxLoc(resImg, &minValue, &maxValue, &minLoc, &maxLoc);
	cout << "2nd max_value= " << maxValue << endl;
	if (maxValue < fMatchThre)
		return false;
	else
		return true;
}


//在图中查找模板图片;
//srcImg & tempImg: 原图和模板图;
//bHcPattern:表示是虚心或是实心模板;
//nMaxCount: 图中最多可能存在的模板;
//vecTempRect:返回值，表示找到的模板区域;
bool CMarkerFinder::LocateTemplate(Mat srcImg, Mat tempImg, bool bHcPattern, float fMatchThre, int nMaxCount, vector<LocMarker> & vecTempRect) {
	
	Mat srcGrayImg;
	Mat tempGrayImg;

	if (srcImg.channels() == 3)
		cvtColor(srcImg, srcGrayImg, CV_BGR2GRAY);
	else
		srcGrayImg = srcImg;
	if (tempImg.channels() == 3)
		cvtColor(tempImg, tempGrayImg, CV_BGR2GRAY);
	else
		tempGrayImg = tempImg;

	int nDelta;
	if (bHcPattern)
		nDelta = m_algParams.locpattern_nHcDelta;
	else
		nDelta = m_algParams.locpattern_nScDelta;

	//对二值化图像进行匹配;
	Mat srcBImg;
	Mat resImg;
	double dthre = threshold(srcGrayImg, srcBImg, 0, 255, THRESH_OTSU);
	cout << "Threshold = " << dthre << endl;

	if (nDelta != 0)
		threshold(srcGrayImg, srcBImg, dthre+nDelta, 255, THRESH_BINARY);

	if (SAVE_FINAL_BINARYIMG_LOCPATTERN)
	{
		imwrite("d:\\finalSrcBImg.jpg", srcBImg);
		imwrite("d:\\finalPtnBImg.jpg", tempGrayImg);
	}

	matchTemplate(srcBImg, tempGrayImg, resImg, CV_TM_CCOEFF_NORMED); //化相关系数匹配法(最好匹配1)

	double minValue, maxValue;
	Point minLoc, maxLoc;
	int nSpace = 25;

	Point preMaxLoc;
	for (int i = 0; i < nMaxCount; i++)
	{
		minMaxLoc(resImg, &minValue, &maxValue, &minLoc, &maxLoc);
		if (maxValue < fMatchThre)
			continue;
		cout << "max_value= " << maxValue << endl;
		cout << "maxLoc_x=" << maxLoc.x << ",maxLoc_y=" << maxLoc.y << endl;

		int startX = maxLoc.x - nSpace;
		if (startX < 0) startX = 0;
		int startY = maxLoc.y - nSpace;
		if (startY < 0) startY = 0;
		int endX = maxLoc.x + nSpace;
		if (endX > resImg.cols - 1)
			endX = resImg.cols - 1;
		int endY = maxLoc.y + nSpace;
		if (endY > resImg.rows - 1)
			endY = resImg.rows - 1;

		//将最高匹配点周围的数据都清空，以免下次匹配还是在附近：
		Mat temp = Mat::zeros(endX - startX, endY - startY, CV_32FC1);
		Rect tempR = Rect(startX, startY, temp.cols, temp.rows);
		temp.copyTo(resImg(tempR));

		LocMarker lm;
		Rect k;
		k.x = maxLoc.x;
		k.y = maxLoc.y;
		k.width = tempImg.cols;
		k.height = tempImg.rows;

		//暗场条件下，无需二次验证;明场时，版和片的号码容易混淆，可能需要二次验证;
		bool bRet = true;
		if (m_algParams.locpattern_bCheckLastNum)
			bRet = CheckLocTemp_ByLastNum(srcBImg, tempGrayImg, fMatchThre, k); //最后一位数字要再次确认;

		if (!bRet)
		{
			//防止坐标未更新造成的死循环;
			if (maxLoc != preMaxLoc)
				nMaxCount++; //由于被末位验证剔除一个候选,因此要多加一轮匹配;

			preMaxLoc = maxLoc;

			continue;
		}
		else
		{
			lm.fConfidence = maxValue;
			lm.rect = k;
			vecTempRect.push_back(lm);
		}

		preMaxLoc = maxLoc;

	}

	return vecTempRect.size();
}

//精确查找Marker;
//srcImg:原图;
//bHollowCross: true为空心十字模板图,false为实心十字模板图;
//dMatchThre:匹配度阈值;
//vecMarkerAreaRect: maker的大致区域，非精细;
//vecMarkerLoc:精确的Marker定位结果,输出参数;
bool CMarkerFinder::LocateMarkerByTempMatch(Mat srcImg, bool bHollowCross, vector<Rect> vecMarkerAreaRect,
	                                  float dMatchThre,vector<LocMarker> &vecMarkerLoc)
{
	int nSize = vecMarkerAreaRect.size();
	if (nSize == 0)
		return false;

	Mat grayTempImg;
	if (bHollowCross)
		grayTempImg = m_hcMarker;
	else
		grayTempImg = m_scMarker;
	
	for (int i = 0; i < nSize; i++) {
		Rect r = vecMarkerAreaRect[i];

		//模板的大小必须比区域更小才能匹配;
		if ((grayTempImg.rows > r.height) || (grayTempImg.cols > r.width))
			continue;

		Mat roiImg = srcImg(r);

		Mat graySrcImg;
		Mat BSrcImg;

		if (roiImg.channels() == 3)
			cvtColor(roiImg, graySrcImg, CV_BGR2GRAY);
		else
			graySrcImg = roiImg;

		threshold(graySrcImg, BSrcImg, 0, 255, THRESH_OTSU);

		//二值图像的匹配：
		Mat resImg;
		matchTemplate(BSrcImg, grayTempImg, resImg, CV_TM_CCOEFF_NORMED); //化相关系数匹配法(最好匹配1)

		double minValue, maxValue;
		Point minLoc, maxLoc;
		minMaxLoc(resImg, &minValue, &maxValue, &minLoc, &maxLoc);

		//匹配度过小的不要;
		if (maxValue < dMatchThre)
			continue;

		//切换回全图坐标;
		Rect k;
		LocMarker lm;
		k.x = maxLoc.x + r.x;
		k.y = maxLoc.y + r.y;
		k.width = grayTempImg.cols;
		k.height = grayTempImg.rows;

		lm.rect = k;
		lm.fConfidence = maxValue;
		vecMarkerLoc.push_back(lm);
	}

	return true;
}

//查找mask的实心十字marker区域;
bool CMarkerFinder::FindMaskMarkerArea(Mat srcImg, Mat bImg, vector<Rect>vecTextLoc, vector<Rect> &vecMarkerRect) {
	
	int nDilateKernalSize = 5;

	//对每一组文字区域进行处理; 
	for (int i = 0; i < vecTextLoc.size();	i++)
	{
		Rect curR = vecTextLoc[i];
		Mat roiImg = bImg(curR);

		//将二值图横纵坐标都缩小8倍
		Mat resizedBImg;
		resize(roiImg, resizedBImg, cvSize(roiImg.cols / 8, roiImg.rows / 8));

		//对二值图进行膨胀,然后检测文字区域;
		Mat dilateBImg;
		Mat kern = getStructuringElement(MORPH_ELLIPSE, Size(nDilateKernalSize, nDilateKernalSize));
		dilate(resizedBImg, dilateBImg, kern);

		//保存膨胀后的图;
		if (ENABLE_TEST) {
			char strFile[256];
			sprintf_s(strFile, "d:\\dialateBImg_%d.jpg", i);
			imwrite(string(strFile), dilateBImg);
		}

		//计算膨胀后的二值图的水平投影;
		int h = dilateBImg.rows;
		int w = dilateBImg.cols;
		int * pHist = new int[h];
		memset(pHist, 0, sizeof(int)*h);
		for (int row = 0; row < h - 1; row++)
		{
			for (int col = 0; col < w; col++)
			{
				char v1 = dilateBImg.at<char>(row, col);
				if (v1 != 0)
					pHist[row]++;
			}
		}

		//查找区域;
		int nStart = 0;
		int nContinusBlack = 0;

		Rect t; //marker区域;
		for (int j = 0; j < h;)
		{
			if (pHist[j] > 0) {
				
				nStart = j;
				while (pHist[j++] && j<h);  //查找白色区域;
				 
				//只选择有一定长度的区域;
				int nLen = j - nStart+1;  //白色区域的长度;
				if (nLen > 22 && nLen < 42 )  //白色区域长度的限制;
				{
					t.y = nStart + nDilateKernalSize;  //原始大小需要加上膨胀时的核大小;
					t.height = nLen + 1 - nDilateKernalSize *2;
					t.x = 0;
					t.width = w;

					//回到原图坐标;
					t.x *= 8;
					t.y *= 8;
					t.width *= 8;
					t.height *= 8;
					//加上ROI区域坐标;
					t.x += curR.x;
					t.y += curR.y;
					vecMarkerRect.push_back(t);
				}

				nContinusBlack = 0;  //连续黑色区域的长度重置;
			}
			else
			{
				j++;
				nContinusBlack++;
			}
		}

		delete[] pHist;
	}
	
	return true;
}

//bImg:输入的二值图;
//struLTParam:用于文字定位的参数;
//nScale:原图的缩放比例;
//查找文字区域的左右垂直边界
void CMarkerFinder::FindTextCord(Mat bImg, LocTexParam struLTParam,vector<Rect> & vecRect) {

	int h = bImg.rows;
	int w = bImg.cols;

	//垂直投影，找阶跃点;
	int * nHist = new int[w];
	memset(nHist, 0, sizeof(int)*w);
	for (int r = 0; r < h - 1; r++)
	{
		//uchar* pdata = img.ptr<uchar>(r);
		for (int c = 0; c < w; c++)
		{
			char v1 = bImg.at<char>(r, c);
			char v2 = bImg.at<char>(r + 1, c);
			if (v1 != v2)
				nHist[c]++;
		}
	}

	//查找条状文字区域,定位左右坐标;
	int nExtend = 20;  //拓展20个像素;
	int nStepThre = struLTParam.nStepCountThre;
	int nTextWidThre = struLTParam.nTextBandWThre;
	for (int i = 0; i < w - 1;)
	{
		//查找具有一定阶跃点的坐标;
		if (nHist[i] > nStepThre) {
			int nStart = i;
			while (nHist[i++] > nStepThre);
			if ((i - nStart) > nTextWidThre)
			{
				Rect rr; 
				//左右边界;
				int x1 = (nStart - nExtend) > 0 ? (nStart - nExtend) : 0;
				int x2 = (i + nExtend) < w ? (i + nExtend) : (w - 1);

				//高度默认为全图高度,上下边界稍后定位;
				rr.x = x1;
				rr.width = x2 - x1 + 1;
				rr.y = 0;
				rr.height = (h - 1);
				vecRect.push_back(rr);
			}
		}
		else
			i++;
	}

	delete[] nHist;

	//定位每个区域的上下边界;
	for (int i = 0; i < vecRect.size(); i++)
	{
		Mat roiBImg = bImg(vecRect[i]);

		int nRoiH = roiBImg.rows;
		int nRoiW = roiBImg.cols;

		int * pHHist = new int[h];
		memset(pHHist, 0, sizeof(int)*h);
		for (int r = 0; r < nRoiH - 1; r++)
		{
			for (int c = 0; c < nRoiW; c++)
			{
				char v1 = roiBImg.at<char>(r, c);
				if (v1)
					pHHist[r]++;
			}
		}

		//分别从上到下记录第一个非零的位置;
		int nTop = 0;
		int nBottom=h-1;
		while (pHHist[nTop++] == 0);
		while (pHHist[nBottom--] == 0);

		//稍微拓展下;
		nTop = (nTop - nExtend) > 0 ? (nTop - nExtend) : 0;
		nBottom = ((nBottom + nExtend) < h) ? (nBottom + nExtend) : (h - 1);
		vecRect[i].y = nTop;
		vecRect[i].height = nBottom - nTop;

		delete[] pHHist;
	}
}

//定位文字区域;
//struLTParam: 文字定位时用的参数;
//bImg:返回的二值图;
//vecLoc:返回的文字区域区间，仅限横坐标;
bool CMarkerFinder::LocateTextArea(Mat srcImg, LocTexParam struLTParam, Mat &bImg, vector<Rect> & vecLoc) {
	int nScale = 2; 

	//缩小一半进行处理;
	Mat resizedSrcImg;
	resize(srcImg, resizedSrcImg, cvSize(srcImg.cols / nScale, srcImg.rows / nScale));
	struLTParam.nTextBandWThre /= nScale;

	Mat gray;
	cvtColor(resizedSrcImg, gray, CV_BGR2GRAY);

	Mat grad_x, grad_y, grad;
	Mat abs_grad_x, abs_grad_y;

	int scale = 1;
	int delta = 0;
	int ddepth = CV_16S;
	/// 求 X方向梯度
	Sobel(gray, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT);
	/// 求 Y方向梯度
	Sobel(gray, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT);

	convertScaleAbs(grad_x, abs_grad_x);
	convertScaleAbs(grad_y, abs_grad_y);
	addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad);

	//二值化;
	double d = threshold(grad, bImg, 0, 255, THRESH_OTSU);
	
	if (ENABLE_TEST)
	{
		imwrite("d:\\grad.jpg", grad);
		imwrite("d:\\bimg.jpg", bImg);
	}

	//查找文字区域;
	FindTextCord(bImg, struLTParam, vecLoc);
	//坐标切回到原图大小;
	for (int i = 0; i < vecLoc.size(); i++)
	{
		vecLoc[i].x *= nScale;
		vecLoc[i].y *= nScale;
		vecLoc[i].width *= nScale;
		vecLoc[i].height *= nScale;
	}

	//画区域;
	//for (int i = 0; i < vecLoc.size(); i++)
	//	rectangle(srcImg, vecLoc[i], Scalar(0, 0, 255), 8);

	if (ENABLE_TEST)
		imwrite("d:\\res.jpg", srcImg);

	//找不到文字区;
	if (vecLoc.size() == 0)
		return false;

	//改回原来的大小
	resize(bImg, bImg, cvSize(bImg.cols * nScale, bImg.rows * nScale));

	return true;
}

//检测实心方框标记坐标;
Rect CMarkerFinder::FT_LocSolidRect(Mat grayImg, Mat bImg, double dthre) {

	//实心检测;
	Mat resImg;
	matchTemplate(bImg, m_scMarker, resImg, CV_TM_CCOEFF_NORMED); //化相关系数匹配法(最好匹配1)

	double minValue, maxValue;
	Point minLoc, maxLoc;

	Rect r_sc;
	minMaxLoc(resImg, &minValue, &maxValue, &minLoc, &maxLoc);
	r_sc.x = maxLoc.x;
	r_sc.y = maxLoc.y;
	r_sc.width = m_scMarker.cols;
	r_sc.height = m_scMarker.rows;

	//在二值图中显示找到的实心十字区域;
	Mat beforeB = bImg;
	//rectangle(beforeB, r_sc, Scalar(0, 0, 0));
	/*namedWindow("before_bimg_S", 0);
	resizeWindow("before_bimg_S", 500, 500);
	imshow("before_bimg_S", beforeB);
	*/
	return r_sc;
}

//计算累积直方图，返回统计个数前fThre时对应的bin;
int CMarkerFinder::FindThreByHist(Mat grayImg, float fThre) {

	//计算灰度直方图;
	int h = grayImg.rows;
	int w = grayImg.cols;
	int nHist[256] = { 0 };
	for (int r = 0; r < h; r++)
	{
		for (int c = 0; c < w; c++)
		{
			uchar v1 = grayImg.at<uchar>(r, c);
			nHist[v1]++;
		}
	}
	//设置为前fThre的灰度值
	int nThre = fThre * h * w;
	int nAccum = 0;
	int i = 0;
	while (nAccum < nThre)
	{
		nAccum = nAccum + nHist[i++];
	}
	int nVal = i - 1;

	return nVal;
}

//仅针对正方形框marker，查找两侧的白色边界。这个白色的边界对外侧的正方形框定位
//有很大影响;
Rect CMarkerFinder::FT_FindWhiteMargin(Mat bImg)
{
	int h = bImg.rows;
	int w = bImg.cols;
	int half_w = w / 2;
	int THRE = 250;

	//左半边;计算相邻三列的均值,如果比较大，则认为是白色的边;
	int nLeft = 0;
	int nRight = w - 1;
	for (int i = half_w; i>=3; i--)
	{
		Mat temp = bImg.colRange(i-3, i);
		double v1 = mean(temp).val[0];
		if (v1 > THRE)
		{
			nLeft = i;
			break;
		}
	}

	//右半边;
	for (int i = half_w-1; i <= w-1; i++)
	{
		Mat temp = bImg.colRange(i - 3, i);
		double v1 = mean(temp).val[0];
		if (v1 > THRE)
		{
			nRight = i-3;
			break;
		}
	}

	Rect r;
	r.x = nLeft;
	r.y = 0;
	r.width = nRight - nLeft + 1;
	r.height = h - 1;

	return r;
}

//精确定位虚心方框的过程中，先去掉实心方框的区域，再进行二值化;
Rect CMarkerFinder::FT_LocHollyRect(Mat grayImg, Mat bImg, double dthre) {

	//实心检测;
	Mat resImg;
	matchTemplate(bImg, m_scMarker, resImg, CV_TM_CCOEFF_NORMED); //化相关系数匹配法(最好匹配1)

	double minValue, maxValue;
	Point minLoc, maxLoc;

	Rect r_sc;
	minMaxLoc(resImg, &minValue, &maxValue, &minLoc, &maxLoc);
	r_sc.x = maxLoc.x;
	r_sc.y = maxLoc.y;
	r_sc.width = m_scMarker.cols;
	r_sc.height = m_scMarker.rows;

	//扩展；
	int m = 10;
	Rect tempRect = r_sc;
	tempRect.x -= m;
	tempRect.y -= m;
	tempRect.width += (m * 2);
	tempRect.height += (m * 2);
	if (tempRect.x < 0) tempRect.x = 0;
	if (tempRect.y < 0) tempRect.y = 0;
	if (tempRect.x + tempRect.width > grayImg.cols)
		tempRect.width = grayImg.cols - tempRect.x - 1;
	if (tempRect.y + tempRect.height > grayImg.rows)
		tempRect.height = grayImg.rows - tempRect.y - 1;
	//虚心方框检测前，先去掉白色的实心区域部分
	Mat tempImg = grayImg;
	int nVal = FindThreByHist(grayImg, 0.2);
	tempImg(tempRect).setTo(Scalar(nVal,nVal,nVal));  //实心区域先全部变成颜色值低的;

	//再次二值化;
	threshold(tempImg, bImg, 0, 255, THRESH_OTSU);
	
	Mat tempMat = m_hcMarker.clone();
	Rect nonWhiteRect;
	nonWhiteRect.x = 0;
	nonWhiteRect.y = 0;
	nonWhiteRect.width = bImg.cols;
	nonWhiteRect.height = bImg.rows;

	//正方形marker，有两侧竖条;
	if (m_algParams.nMarkerType == 2)
	{
		//去除白色边界;
		nonWhiteRect = FT_FindWhiteMargin(bImg);
		//cvtColor(testImg, testImg, CV_GRAY2BGR);
		//rectangle(testImg, rr, Scalar(255, 0, 0), 1);
		//imwrite("d:\\test.jpg", testImg);

		//在二值化图中匹配;
		bImg = bImg(nonWhiteRect);
		//模板的宽度一定要小于图像的宽度;
		if (bImg.cols <= tempMat.cols) {
			int nW = bImg.cols - 1;
			int nH = int((double)nW * (double)tempMat.rows / (double)tempMat.cols + 0.5);
			resize(tempMat, tempMat, cvSize(nW, nH));
		}
	}
	
	matchTemplate(bImg, tempMat, resImg, CV_TM_CCOEFF_NORMED); //化相关系数匹配法(最好匹配1)

	Rect r_hc;
	minMaxLoc(resImg, &minValue, &maxValue, &minLoc, &maxLoc);
	r_hc.x = maxLoc.x + nonWhiteRect.x;
	r_hc.y = maxLoc.y;
	r_hc.width = m_hcMarker.cols;
	r_hc.height = m_hcMarker.rows;

	return r_hc;
}

//检测实心十字标记坐标;
Rect CMarkerFinder::FT_LocSolidCross(Mat grayImg, Mat bImg, double dthre) {
	double dRatioThre = 0.8;  //有些图片0.6即可;

	int nSize = bImg.rows*bImg.cols;
	float fRatio = countNonZero(bImg)*1.0 / nSize;
	//cout << "1: non-zero=" << fRatio << endl;

	double dFloor = dthre * 0.5; //阈值不能过低;
	//白色占比达到一定比例，保证二值化后黑色十字比较精准;
	while (fRatio < dRatioThre) {
		dthre = threshold(grayImg, bImg, dthre - 5, 255, THRESH_BINARY);
		fRatio = countNonZero(bImg)*1.0 / nSize;
		dthre -= 5;

		if (dthre < dFloor)
			break;
	}

	//实心十字检测;
	Mat resImg;
	matchTemplate(bImg, m_scMarker, resImg, CV_TM_CCOEFF_NORMED); //化相关系数匹配法(最好匹配1)

	double minValue, maxValue;
	Point minLoc, maxLoc;

	Rect r_sc;
	minMaxLoc(resImg, &minValue, &maxValue, &minLoc, &maxLoc);
	r_sc.x = maxLoc.x;
	r_sc.y = maxLoc.y;
	r_sc.width = m_scMarker.cols;
	r_sc.height = m_scMarker.rows;

	//在二值图中显示找到的实心十字区域;
	Mat beforeB = bImg;
	//rectangle(beforeB, r_sc, Scalar(0, 0, 0));
	/*namedWindow("before_bimg_S", 0);
	resizeWindow("before_bimg_S", 500, 500);
	imshow("before_bimg_S", beforeB);
	*/
	return r_sc;
}

Rect CMarkerFinder::FT_LocHollyCross(Mat grayImg, Mat bImg, double dthre) {
	double dPhase1_RatioThre = 0.6;  //用于实心十字检测;
	double dPhase2_RatioThre = 0.1;  //有些地方是0.05就可以;0.1

	if (m_algParams.bFlag_AfterAL == 1)
		dPhase2_RatioThre = 0.05;

	int nSize = bImg.rows*bImg.cols;
	float fRatio = countNonZero(bImg)*1.0 / nSize;
	//cout << "1: non-zero=" << fRatio << endl;

	double dFloor = dthre * 0.5; //阈值不能过低;
	//白色占比达到一定比例，保证二值化后黑色十字比较精准;
	while (fRatio < dPhase1_RatioThre) {
		dthre = threshold(grayImg, bImg, dthre - 10, 255, THRESH_BINARY);
		fRatio = countNonZero(bImg)*1.0 / nSize;
		dthre -= 10;

		if (dthre < dFloor)
			break;
	}

	//实心十字检测;
	Mat resImg;
	matchTemplate(bImg, m_scMarker, resImg, CV_TM_CCOEFF_NORMED); //化相关系数匹配法(最好匹配1)

	double minValue, maxValue;
	Point minLoc, maxLoc;

	Rect r_sc;
	minMaxLoc(resImg, &minValue, &maxValue, &minLoc, &maxLoc);
	r_sc.x = maxLoc.x;
	r_sc.y = maxLoc.y;
	r_sc.width = m_scMarker.cols;
	r_sc.height = m_scMarker.rows;

	/*
	Mat beforeB = bImg;
	//rectangle(beforeB, r_sc, Scalar(0, 0, 0), 1);
	namedWindow("HC_phase1Img", 0);
	resizeWindow("HC_phase1Img", 500, 500);
	imshow("HC_phase1Img", beforeB);
	*/

	//实心区域先全部变成白色;
	bImg(r_sc).setTo(Scalar(255, 255, 255));  

	Mat tempV;
	Mat newTemp;  //实际的空心十字,可能和模板大小稍有差异;
	Rect r;
	r.x = m_algParams.finetune_nHcMargin;
	r.y = m_algParams.finetune_nHcMargin;
	r.width = m_hcMarker.cols - 2 * m_algParams.finetune_nHcMargin;
	r.height = m_hcMarker.rows - 2 * m_algParams.finetune_nHcMargin;
	newTemp = m_hcMarker(r);
	bitwise_not(newTemp, tempV);  //空心十字，反色;

    //虚心十字检测：
	//保证虚心十字区域二值化后有一定数量;
	int nZeroCount;
	nZeroCount = nSize - countNonZero(bImg);
	while (nZeroCount < dPhase2_RatioThre * nSize) 
	{
		threshold(grayImg, bImg, dthre + 10, 255, THRESH_BINARY);
		bImg(r_sc).setTo(Scalar(255, 255, 255));  //实心区域先全部变成白色;
		nZeroCount = nSize - countNonZero(bImg);
		dthre += 10;

		if (dthre > 230)
			break;
	}
	
	/*
	namedWindow("HC_phase2Img", 0);
	resizeWindow("HC_phase2Img", 500, 500);
	imshow("HC_phase2Img", bImg);
	*/

	matchTemplate(bImg, tempV, resImg, CV_TM_CCOEFF_NORMED); //化相关系数匹配法(最好匹配1)

	Rect r_hc;
	minMaxLoc(resImg, &minValue, &maxValue, &minLoc, &maxLoc);
	r_hc.x = maxLoc.x;
	r_hc.y = maxLoc.y;
	r_hc.width = tempV.cols;
	r_hc.height = tempV.rows;
	
	return r_hc;
}

//对给定的mat定位其开始和结尾
bool CMarkerFinder::FT_FindBoundary(Mat data, int & s, int & e) {

	double dThre = 30;  //黑色边框区域的均值阈值;

	int nSize = data.cols;
	int nStart = 0;
	while (data.at<double>(nStart) < dThre)
		nStart++;
	
	int nEnd = nSize - 1;
	while (data.at<double>(nEnd) < dThre)
		nEnd--;

	s = nStart;
	e = nEnd;

	return true;
}

//仅用于十字架marker
//查找原图中的黑色边框区域.黑色边框区域会影响算法;
//返回的是不包含黑色边框的图像区域;
bool CMarkerFinder::FT_FindBlackMargin(Mat srcImg,Rect &r) {

	int h = srcImg.rows;
	int w = srcImg.cols;
	int nChannel = srcImg.channels();

	//处理灰度图
	if (nChannel == 3)
		return false;

	Mat srcR,srcC;  //row和col对应的mat;
	srcR.create(1, h, CV_64FC1);
	srcC.create(1, w, CV_64FC1);

	//行的值：
	for (int i = 0; i < h; i++)
	{
		Mat temp = srcImg.rowRange(i, i + 1);
		double v = mean(temp).val[0];
		srcR.at<double>(i) = v;
	}

	//列的值;
	for (int i = 0; i < w; i++)
	{
		Mat temp = srcImg.colRange(i, i + 1);
		double v = mean(temp).val[0];
		srcC.at<double>(i) = v;
	}

	int nRolStart = 0;
	int nRolEnd   = h - 1;
	int nColStart = 0;
	int nColEnd   = w - 1;
	FT_FindBoundary(srcR, nRolStart, nRolEnd);
	FT_FindBoundary(srcC, nColStart, nColEnd);

	r.x = nColStart;
	r.y = nRolStart;
	r.width = nColEnd - nColStart;
	r.height = nRolEnd - nRolStart;

	//用于分析的区域不能小于虚心marker的大小;
	if (r.width < m_hcMarker.cols || r.height < m_hcMarker.rows)
		return false;

	return true;
}

//精调阶段的虚方框调整;
bool CMarkerFinder::FT_RefineHollyRect(Mat grayImg, Rect &rectH) {
	int nExtMargin = 20;  //扩展范围;
	int nShrinkMargin = 0;  //范围稍微往里面收缩一点;

	int nHollyRectSize = m_algParams.refine_nHcThickSize;
	int nRow, nCol;

	Mat srcImg;
	if (grayImg.channels() == 3)
		cvtColor(grayImg, srcImg, CV_BGR2GRAY);
	else
		srcImg = grayImg;

	//存储每行/列的一二阶梯度和;
	Mat xGradImg, yGradImg;
	xGradImg = Mat::zeros(srcImg.size(), CV_16SC1);
	yGradImg = Mat::zeros(srcImg.size(), CV_16SC1);
	for (int rr = 2; rr < srcImg.rows - 2; rr++)
		for (int cc = 2; cc < srcImg.cols - 2; cc++)
		{
			xGradImg.at<short int>(rr, cc) = abs(srcImg.at<uchar>(rr, cc));
			//xGradImg.at<short int>(rr, cc) += abs(srcImg.at<uchar>(rr, cc - 1) + srcImg.at<uchar>(rr, cc + 1));
			//xGradImg.at<short int>(rr, cc) += abs(srcImg.at<uchar>(rr, cc - 2) + srcImg.at<uchar>(rr, cc + 2));
			
			yGradImg.at<short int>(rr, cc) = abs(srcImg.at<uchar>(rr, cc));
			//yGradImg.at<short int>(rr, cc) += abs(srcImg.at<uchar>(rr - 1, cc) + srcImg.at<uchar>(rr + 1, cc));
			//yGradImg.at<short int>(rr, cc) += abs(srcImg.at<uchar>(rr - 2, cc) + srcImg.at<uchar>(rr + 2, cc));
		}

	int nCenterX = rectH.x + rectH.width / 2;
	int nCenterY = rectH.y + rectH.height / 2;

	//水平方向的边界侦测
	int l = rectH.x + nShrinkMargin;
	int r = rectH.x + rectH.width - 1 - nShrinkMargin;
	int t = nCenterY - nHollyRectSize / 2 - nExtMargin;
	int b = nCenterY + nHollyRectSize / 2 + nExtMargin;
	if (t < 0) t = 0;
	if (b > srcImg.rows) b = srcImg.rows - 1;

	//计算最大梯度;
	int nTotal = 0;
	int nLineY;
	for (nRow = t; nRow < b - nHollyRectSize; nRow++)
	{
		int nSumUpEdge = 0;
		int nSumDownEdge = 0;
		for (nCol = l; nCol < r; nCol++)
		{
			nSumUpEdge += yGradImg.at<short int>(nRow, nCol);
			nSumDownEdge += yGradImg.at<short int>(nRow + nHollyRectSize, nCol);
		}

		int nTemp = nSumDownEdge + nSumUpEdge;
		if (nTotal < nTemp) {
			nTotal = nTemp;
			nLineY = nRow;
		}
	}

	//垂直方向的边界侦测
	l = nCenterX - nHollyRectSize / 2 - nExtMargin;
	r = nCenterX + nHollyRectSize / 2 + nExtMargin;
	t = rectH.y + nShrinkMargin;
	b = rectH.y + rectH.height - 1 - nShrinkMargin;
	if (l < 0)l = 0;
	if (r > srcImg.cols) r = srcImg.cols - 1;

	nTotal = 0;
	int nLineX;
	for (nCol = l; nCol < r - nHollyRectSize; nCol++)
	{
		int nSumLeftEdge = 0;
		int nSumRightEdge = 0;
		for (nRow = t; nRow < b; nRow++)
		{
			nSumLeftEdge += xGradImg.at<short int>(nRow, nCol);
			nSumRightEdge += xGradImg.at<short int>(nRow, nCol + nHollyRectSize);
		}

		int nTemp = nSumLeftEdge + nSumRightEdge;
		if (nTotal < nTemp) {
			nTotal = nTemp;
			nLineX = nCol;
		}
	}

	rectH.x = nLineX;
	rectH.width = nHollyRectSize;
	rectH.y = nLineY;
	rectH.height = nHollyRectSize;

	return true;
}

bool CMarkerFinder::FT_RefineSolidRect(Mat grayImg, Rect &rectS) {
	int nExtMargin = 5;  //扩展范围;
	int nShrinkMargin = 0;  //范围稍微往里面收缩一点;

	int nSolidRectSize = m_algParams.refine_nScThickSize;
	int nRow, nCol;

	Mat srcImg;
	if (grayImg.channels() == 3)
		cvtColor(grayImg, srcImg, CV_BGR2GRAY);
	else
		srcImg = grayImg;

	//存储每行/列的一二阶梯度和;
	Mat xGradImg, yGradImg;
	xGradImg = Mat::zeros(srcImg.size(), CV_16SC1);
	yGradImg = Mat::zeros(srcImg.size(), CV_16SC1);
	for (int rr = 2; rr < srcImg.rows - 2; rr++)
		for (int cc = 2; cc < srcImg.cols - 2; cc++)
		{
			xGradImg.at<short int>(rr, cc) = abs(srcImg.at<uchar>(rr, cc - 1) - srcImg.at<uchar>(rr, cc + 1));
			xGradImg.at<short int>(rr, cc) += abs(srcImg.at<uchar>(rr, cc - 2) - srcImg.at<uchar>(rr, cc + 2));

			yGradImg.at<short int>(rr, cc) = abs(srcImg.at<uchar>(rr - 1, cc) - srcImg.at<uchar>(rr + 1, cc));
			yGradImg.at<short int>(rr, cc) += abs(srcImg.at<uchar>(rr - 2, cc) - srcImg.at<uchar>(rr + 2, cc));
		}

	int nCenterX = rectS.x + rectS.width / 2;
	int nCenterY = rectS.y + rectS.height / 2;

	//水平方向的边界侦测
	int l = rectS.x + nShrinkMargin;
	int r = rectS.x + rectS.width - 1 - nShrinkMargin;
	int t = nCenterY - nSolidRectSize / 2 - nExtMargin;
	int b = nCenterY + nSolidRectSize / 2 + nExtMargin;

	//计算最大梯度;
	int nTotal = 0;
	int nLineY;
	for (nRow = t; nRow < b - nSolidRectSize; nRow++)
	{
		int nSumUpEdge = 0;
		int nSumDownEdge = 0;
		for (nCol = l; nCol < r; nCol++)
		{
			nSumUpEdge += yGradImg.at<short int>(nRow, nCol);
			nSumDownEdge += yGradImg.at<short int>(nRow + nSolidRectSize, nCol);
		}

		int nTemp = nSumDownEdge + nSumUpEdge;
		if (nTotal < nTemp) {
			nTotal = nTemp;
			nLineY = nRow;
		}
	}

	//垂直方向的边界侦测
	l = nCenterX - nSolidRectSize / 2 - nExtMargin;
	r = nCenterX + nSolidRectSize / 2 + nExtMargin;
	t = rectS.y + nShrinkMargin;
	b = rectS.y + rectS.height - 1 - nShrinkMargin;

	nTotal = 0;
	int nLineX;
	for (nCol = l; nCol < r - nSolidRectSize; nCol++)
	{
		int nSumLeftEdge = 0;
		int nSumRightEdge = 0;
		for (nRow = t; nRow < b; nRow++)
		{
			nSumLeftEdge += xGradImg.at<short int>(nRow, nCol);
			nSumRightEdge += xGradImg.at<short int>(nRow, nCol + nSolidRectSize);
		}

		int nTemp = nSumLeftEdge + nSumRightEdge;
		if (nTotal < nTemp) {
			nTotal = nTemp;
			nLineX = nCol;
		}
	}

	rectS.x = nLineX;
	rectS.width = nSolidRectSize;
	rectS.y = nLineY;
	rectS.height = nSolidRectSize;

	return true;
}

//重新调整虚框的位置;通过计算相应四条边的灰度值总和，以最小值作为最终的选择;
bool CMarkerFinder::FT_RefineHollyCross(Mat grayImg, Rect &rectH) {
	int nHMargin = m_algParams.refineHC_nMarginH;  //扩展范围; H表示水平，V表示垂直;
	int nVMargin = m_algParams.refineHC_nMarginV;
	
	//实际大小与模板大小稍有差异,尽量定位在边框的中心线上,因此要减去边框宽度;
	rectH.width  -= m_algParams.refine_nHcThickSize;
	rectH.height -= m_algParams.refine_nHcThickSize;

	//只计算最中间的1/3长度边;
	int nSubColStart = 0.33 * rectH.width;
	int nSubColEnd = 0.66 * rectH.width;
	int nSubRowStart = 0.33 * rectH.height;
	int nSubRowEnd = 0.66 * rectH.height;

	int nTotal = 1000000;
	int nDeltaX = 0;
	int nDeltaY = 0;
	for (int nRow = -nVMargin; nRow <= nVMargin; nRow++)
	for (int nCol = -nHMargin; nCol <= nHMargin; nCol++)
	{
		//边界合理性判断;
		int l = rectH.x + nCol;
		int t = rectH.y + nRow;
		int r = l + rectH.width - 1;
		int b = t + rectH.height - 1;
		if (l-1<0 || t-1<0 || r+1>=grayImg.rows || b+1>=grayImg.cols)
			continue;

		//上下边界;统计上下连续三条边的总和;
		int nSumTop = 0;
		int nSumBot = 0;
		for (int subCol = l + nSubColStart; subCol <= l + nSubColEnd; subCol++)
		{
			//top
			nSumTop = nSumTop + grayImg.at<uchar>(t, subCol) + grayImg.at<uchar>(t-1, subCol) + grayImg.at<uchar>(t+1, subCol);
			//bottom;
			nSumBot = nSumBot + grayImg.at<uchar>(b, subCol) + grayImg.at<uchar>(b - 1, subCol) + grayImg.at<uchar>(b + 1, subCol);
		}
		//左右边界;
		int nSumLeft = 0;
		int nSumRight = 0;
		for (int subRow = t + nSubRowStart; subRow <= t + nSubRowEnd; subRow++) {
			nSumLeft = nSumLeft + grayImg.at<uchar>(subRow, l) + grayImg.at<uchar>(subRow, l + 1) + grayImg.at<uchar>(subRow, l - 1);
			nSumRight = nSumRight + grayImg.at<uchar>(subRow, r)+grayImg.at<uchar>(subRow, r + 1) + grayImg.at<uchar>(subRow, r - 1);
		}

		//查找四条边的亮度之和最低的;
		int nTemp = nSumLeft + nSumRight + nSumTop + nSumBot;
		if (nTotal > nTemp) {
			nTotal = nTemp;
			nDeltaX = nCol;
			nDeltaY = nRow;
		}
	}

	rectH.x += nDeltaX;
	rectH.y += nDeltaY;

	//未做任何改变;
	if (nDeltaX == 0 && nDeltaY == 0)
		return false;
	else
		return true;
}

bool CMarkerFinder::FT_RefineWhiteRect(Mat grayImg, Rect &rectW) {
	int nExtMargin = 5;  //扩展范围;
	int nShrinkMargin = 0;  //范围稍微往里面收缩一点;

	int nWhiteRectSize = 155;
	rectW.x = 0;
	rectW.y = 0;
	rectW.width = grayImg.cols - 1;
	rectW.height = grayImg.rows - 1;

	int nRow, nCol;

	Mat srcImg;
	if (grayImg.channels() == 3)
		cvtColor(grayImg, srcImg, CV_BGR2GRAY);
	else
		srcImg = grayImg;

	//存储每行/列的一二阶梯度和;
	Mat xGradImg, yGradImg;
	xGradImg = Mat::zeros(srcImg.size(), CV_16SC1);
	yGradImg = Mat::zeros(srcImg.size(), CV_16SC1);
	for (int rr = 2; rr < srcImg.rows - 2; rr++)
		for (int cc = 2; cc < srcImg.cols - 2; cc++)
		{
			xGradImg.at<short int>(rr, cc) = abs(srcImg.at<uchar>(rr, cc - 1) - srcImg.at<uchar>(rr, cc + 1));
			xGradImg.at<short int>(rr, cc) += abs(srcImg.at<uchar>(rr, cc - 2) - srcImg.at<uchar>(rr, cc + 2));

			yGradImg.at<short int>(rr, cc) = abs(srcImg.at<uchar>(rr - 1, cc) - srcImg.at<uchar>(rr + 1, cc));
			yGradImg.at<short int>(rr, cc) += abs(srcImg.at<uchar>(rr - 2, cc) - srcImg.at<uchar>(rr + 2, cc));
		}

	int nCenterX = rectW.x + rectW.width / 2;
	int nCenterY = rectW.y + rectW.height / 2;

	//水平方向的边界侦测
	int l = rectW.x + nShrinkMargin;
	int r = rectW.x + rectW.width - 1 - nShrinkMargin;
	int t = nCenterY - nWhiteRectSize / 2 - nExtMargin;
	int b = nCenterY + nWhiteRectSize / 2 + nExtMargin;

	int nTotal = 0;
	int nLineY;
	for (nRow = t; nRow < b - nWhiteRectSize; nRow++)
	{
		int nSumUpEdge = 0;
		int nSumDownEdge = 0;
		for (nCol = l; nCol < r; nCol++)
		{
			nSumUpEdge += yGradImg.at<short int>(nRow, nCol);
			nSumDownEdge += yGradImg.at<short int>(nRow + nWhiteRectSize, nCol);
		}

		int nTemp = nSumDownEdge + nSumUpEdge;
		if (nTotal < nTemp) {
			nTotal = nTemp;
			nLineY = nRow;
		}
	}

	//垂直方向的边界侦测
	l = nCenterX - nWhiteRectSize / 2 - nExtMargin;
	r = nCenterX + nWhiteRectSize / 2 + nExtMargin;
	t = rectW.y + nShrinkMargin;
	b = rectW.y + rectW.height - 1 - nShrinkMargin;

	nTotal = 0;
	int nLineX;
	for (nCol = l; nCol < r - nWhiteRectSize; nCol++)
	{
		int nSumLeftEdge = 0;
		int nSumRightEdge = 0;
		for (nRow = t; nRow < b; nRow++)
		{
			nSumLeftEdge += xGradImg.at<short int>(nRow, nCol);
			nSumRightEdge += xGradImg.at<short int>(nRow, nCol + nWhiteRectSize);
		}

		int nTemp = nSumLeftEdge + nSumRightEdge;
		if (nTotal < nTemp) {
			nTotal = nTemp;
			nLineX = nCol;
		}
	}

	
	Rect rect(l, t, r - l + 1, b - t + 1);
	//rectangle(grayImg, rect, Scalar(255, 255, 255));
	line(grayImg, Point(0, nLineY), Point(grayImg.cols - 1, nLineY), Scalar(255, 255, 255));
	line(grayImg, Point(0, nLineY + nWhiteRectSize), Point(grayImg.cols - 1, nLineY + nWhiteRectSize), Scalar(255, 255, 255));
	line(grayImg, Point(nLineX, 0), Point(nLineX,grayImg.rows - 1), Scalar(255, 255, 255));
	line(grayImg, Point(nLineX + nWhiteRectSize,0), Point(nLineX+ nWhiteRectSize,grayImg.rows - 1), Scalar(255, 255, 255));

	namedWindow("line", 0);
	resizeWindow("line", 500, 500);
	imshow("line", grayImg);
	

	rectW.x = nLineX;
	rectW.width = nWhiteRectSize;
	rectW.y = nLineY;
	rectW.height = nWhiteRectSize;

	return true;
}

bool CMarkerFinder::FT_RefineSolidCross(Mat grayImg, Rect &rectS) {
	int nExtMargin = 5;  //扩展范围;
	int nShrinkMargin = 0;  //范围稍微往里面收缩一点;

	int nSolidCrossSize = m_algParams.refine_nScThickSize;
	int nRow, nCol;

	Mat srcImg;
	if (grayImg.channels() == 3)
		cvtColor(grayImg, srcImg, CV_BGR2GRAY);
	else
		srcImg = grayImg;


	//存储每行/列的一二阶梯度和;
	Mat xGradImg, yGradImg;
	xGradImg = Mat::zeros(srcImg.size(), CV_16SC1);
	yGradImg = Mat::zeros(srcImg.size(), CV_16SC1);
	for (int rr = 2; rr < srcImg.rows - 2; rr++)
	for (int cc = 2; cc < srcImg.cols - 2;cc++)
	{
		xGradImg.at<short int>(rr, cc) = abs(srcImg.at<uchar>(rr, cc - 1) - srcImg.at<uchar>(rr, cc + 1));
		xGradImg.at<short int>(rr, cc) += abs(srcImg.at<uchar>(rr, cc - 2) - srcImg.at<uchar>(rr, cc + 2));

		yGradImg.at<short int>(rr, cc) = abs(srcImg.at<uchar>(rr - 1, cc) - srcImg.at<uchar>(rr + 1, cc));
		yGradImg.at<short int>(rr, cc) += abs(srcImg.at<uchar>(rr - 2, cc) - srcImg.at<uchar>(rr + 2, cc));
	}

	int nCenterX = rectS.x + rectS.width / 2;
	int nCenterY = rectS.y + rectS.height / 2;

	//水平方向的边界侦测
	int l = rectS.x+nShrinkMargin;
	int r = rectS.x + rectS.width - 1 - nShrinkMargin;
	int t = nCenterY - nSolidCrossSize / 2 - nExtMargin;
	int b = nCenterY + nSolidCrossSize / 2 + nExtMargin;

	int nTotal = 0;
	int nLineY;
	for (nRow = t; nRow < b-nSolidCrossSize; nRow++)
	{
		int nSumUpEdge = 0;
		int nSumDownEdge = 0;
		for (nCol = l; nCol < r; nCol++)
		{
			nSumUpEdge += yGradImg.at<short int>(nRow, nCol);
			nSumDownEdge += yGradImg.at<short int>(nRow+nSolidCrossSize,nCol);
		}

		int nTemp = nSumDownEdge + nSumUpEdge;
		if (nTotal < nTemp) {
			nTotal = nTemp;
			nLineY = nRow;
		}
	}

	//垂直方向的边界侦测
	l = nCenterX - nSolidCrossSize / 2 - nExtMargin;
	r = nCenterX + nSolidCrossSize / 2 + nExtMargin;
	t = rectS.y+nShrinkMargin;
	b = rectS.y + rectS.height - 1 - nShrinkMargin;

	nTotal = 0;
	int nLineX;
	for (nCol = l; nCol < r - nSolidCrossSize; nCol++)
	{
		int nSumLeftEdge = 0;
		int nSumRightEdge = 0;
		for (nRow = t; nRow < b; nRow++)
		{
			nSumLeftEdge += xGradImg.at<short int>(nRow, nCol);
			nSumRightEdge += xGradImg.at<short int>(nRow, nCol + nSolidCrossSize);
		}

		int nTemp = nSumLeftEdge + nSumRightEdge;
		if (nTotal < nTemp) {
			nTotal = nTemp;
			nLineX = nCol;
		}
	}
	
	/*
	Rect rect(l, t, r - l + 1, b - t + 1);
	rectangle(grayImg, rect, Scalar(255, 255, 255));
	line(grayImg, Point(0, nLineY), Point(grayImg.cols - 1, nLineY), Scalar(255, 255, 255));
	line(grayImg, Point(0, nLineY + nSolidCrossSize), Point(grayImg.cols - 1, nLineY + nSolidCrossSize), Scalar(255, 255, 255));
	line(grayImg, Point(nLineX, 0), Point(nLineX,grayImg.rows - 1), Scalar(255, 255, 255));
	line(grayImg, Point(nLineX + nSolidCrossSize,0), Point(nLineX+nSolidCrossSize,grayImg.rows - 1), Scalar(255, 255, 255));

	namedWindow("line", 0);
	resizeWindow("line", 500, 500);
	imshow("line", grayImg);
	*/

	rectS.x = nLineX;
	rectS.width = nSolidCrossSize;
	rectS.y = nLineY;
	rectS.height = nSolidCrossSize;

	return true;
}

//根据十字框微调实心十字rect位置。实心十字如果离虚心十字太近了，则往相反方向稍微移动一点.
//两者靠的太近时,二值化容易黏在一起,导致匹配时产生偏差.往反方向移动可以抵消这种偏差。
bool CMarkerFinder::FT_AdjustRect(Rect & rH, Rect &rS) {
	int DIST = 4;  //距离阈值;
	int MOVE = 3;  //移动值
	bool bAdjust = false;

	//左边
	if (abs(rS.x - rH.x) <= DIST)
	{
		rS.x += MOVE;
		bAdjust = true;
	}
	//右边
	else {
		int rightS = rS.x + rS.width;
		int rightH = rH.x + rH.width;
		if (abs(rightH - rightS) <= DIST)
		{
			rS.x -= MOVE;
			bAdjust = true;
		}
	}

	//上边;
	if (abs(rS.y - rH.y) <= DIST)
	{
		rS.y += MOVE;
		bAdjust = true;
	}
	else {
		int bottomS = rS.y + rS.height;
		int bottomH = rH.y + rH.height;
		if (abs(bottomH - bottomS) <= DIST)
		{
			rS.y -= MOVE;
			bAdjust = true;
		}
	}

	return bAdjust;
}

//正方形标记的细调;
bool CMarkerFinder::FinalFinetune_Rect(Mat srcImg, Mat &bImg, Rect &rectH, Rect &rectS) {
	
	Mat b;
	Mat GrayImg;

	if (srcImg.channels() == 3)
		cvtColor(srcImg, GrayImg, CV_BGR2GRAY);
	else
		GrayImg = srcImg;

	double dthre = threshold(GrayImg, b, 0, 255, THRESH_OTSU);

	//查找虚心实心十字坐标;
	Mat b2 = b.clone();
	rectS = FT_LocSolidRect(GrayImg, b, dthre);
	rectH = FT_LocHollyRect(GrayImg, b2, dthre);

	//调整虚心十字框的坐标;
	Mat tempImg = GrayImg;
	Rect tempRect = rectS;//适当扩大区域;
	int m = 5;
	tempRect.x -= m;
	tempRect.y -= m;
	tempRect.width += (m * 2);
	tempRect.height += (m * 2);
	if (tempRect.x < 0) tempRect.x = 0;
	if (tempRect.y < 0) tempRect.y = 0;
	if (tempRect.x + tempRect.width > GrayImg.cols)
		tempRect.width = GrayImg.cols - tempRect.x - 1;
	if (tempRect.y + tempRect.height > GrayImg.rows)
		tempRect.height = GrayImg.rows - tempRect.y - 1;
	
	int nVal = FindThreByHist(GrayImg, 0.2);
	tempImg(tempRect).setTo(Scalar(nVal, nVal, nVal));  //将实心方框区域设为某个较低的值;

	//正方形marker，无两侧竖条;
	if (m_algParams.nMarkerType == 1)
		FT_RefineHollyRect(tempImg, rectH);

	rectangle(b2, rectS, Scalar(0, 0, 0), 1);
	rectangle(b2, rectH, Scalar(0, 0, 0), 1);

	bImg = b2;

	return true;

}

//十字标记的细调;
bool CMarkerFinder::FinalFinetune(Mat srcImg, Mat &bImg,Rect &rectH,Rect &rectS) {

	Mat b;
	Mat GrayImg;

	if (srcImg.channels() == 3)
		cvtColor(srcImg, GrayImg, CV_BGR2GRAY);
	else
		GrayImg = srcImg;

	Rect newRect;
	if (!FT_FindBlackMargin(GrayImg, newRect))
		return false;

	Mat gImg = GrayImg(newRect);
	double dthre = threshold(gImg, b, 0, 255, THRESH_OTSU);

	//查找虚心实心十字坐标;
	Mat b2 = b.clone();
	rectS = FT_LocSolidCross(gImg, b, dthre);
	rectH = FT_LocHollyCross(gImg, b2, dthre);

	//调整虚心十字框的坐标;
	FT_RefineHollyCross(gImg, rectH);

	rectS.x = rectS.x + newRect.x;
	rectS.y = rectS.y + newRect.y;
	rectH.x = rectH.x + newRect.x;
	rectH.y = rectH.y + newRect.y;

	//调整实心十字框;实心十字贴的虚心十字太近时，容易产生偏差;
	FT_AdjustRect(rectH, rectS);

	rectangle(b2, rectS, Scalar(0, 0, 0), 1);
	rectangle(b2, rectH, Scalar(0, 0, 0), 1);
	
	bImg = b2;

	return true;
}

void CMarkerFinder::Util_GenTempImg(Mat srcImg, int nDelta,Mat &outImg) {
	Mat Gray, b;
	if (srcImg.channels() == 3)
		cvtColor(srcImg, Gray, CV_BGR2GRAY);
	else
		Gray = srcImg;

	double dthre = threshold(Gray, b, 0, 255, THRESH_OTSU);
	threshold(Gray, b, dthre + nDelta, 255, THRESH_BINARY);

	outImg = b;
}
